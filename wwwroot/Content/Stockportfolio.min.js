import { Start as hA } from "./WebSharper.Core.JavaScript/Runtime.js"
import { Lazy as hB, Create as hC, MarkResizable as hD, SetOptional as hE, Force as hF, GetOptional as hG, CreateFuncWithArgs as hH, DeleteEmptyFields as hI, OnLoad as hJ } from "./WebSharper.Core.JavaScript/Runtime.js"
function a(hK){ return"Dispose"in hK;}
function b(){ return e.Main;}
function c(){ return e.router;}
function d(){ return e.currentPage;}
let e=hB((hK) => class hL { static { e=hK(this);} static Main;static currentPage;static router;static EquityModel;static EquityData;static random;static stockA;static stockN;static stockP;static totalExpensesView;static totalIncomeView;static balanceView;static storage_e;static storage_i;static expensegroup;static loss;static totalE;static gain;static incomegroup;static totalG;static { const hM=[n.Create_1(""), n.Create_1(0), n.Create_1(0)];this.totalG=hM[2];this.incomegroup=hM[0];this.gain=hM[1];const hN=[n.Create_1(""), n.Create_1(0), n.Create_1(0)];this.totalE=hN[2];this.loss=hN[1];this.expensegroup=hN[0];const hO=[n.Create_1([h.Empty, h.Empty]), n.Create_1([h.Empty, h.Empty])];this.storage_i=hO[0];this.storage_e=hO[1];this.balanceView=Q((hZ, h0) =>(hZ-h0).toFixed(2), p().View, o().View);this.totalIncomeView=R((hZ) => hZ.toFixed(2), p().View);this.totalExpensesView=R((hZ) => hZ.toFixed(2), o().View);const hP=[n.Create_1(""), n.Create_1(0), n.Create_1(0)];this.stockP=hP[2];this.stockN=hP[0];this.stockA=hP[1];this.random=new j();this.EquityData=h.Empty;const hQ=u0035((hZ) => hZ.Name, r());let hR=(S((hZ) => { q(u0037(hZ));}, hQ.v),hQ);this.EquityModel=hR;this.router=bg();this.currentPage=bk({$:0}, c());const hS=c_.EmbedView(R((hZ) => hZ.$==1?s():t(), d().View));const hT=new bs("New_1");const hU=(hT.h.push(new c6("balances", "/#/")),hT);const hV=(hU.h.push(new c6("equities", "/#/stockPortfolio")),hU);const hW=(hV.h.push(new c5("pagecontent", hS)),hV);const hX=c9(hW.k, hW.h, []);let hY=hW.i=new c4(hX[1], ev(hX[0]));this.Main=hY;} });
let f=hB((hK) => class hL { static { f=hK(this);} Equals(hM){ return this===hM;} GetHashCode(){ return -1;} });
let g=hB((hK) => class hL extends f { static { g=hK(this);} });
let h=hB((hK) => class hL { static { h=hK(this);} static Empty=hC(h, {$:0});static Cons(hM, hN){ return hC(hL, {$:1, $0:hM, $1:hN});} GetEnumerator(){ return new eh(this, null, (hM) => { const hN=hM.s;return hN.$==0?false:(hM.c=hN.$0,hM.s=hN.$1,true);}, void 0);} });
let i=hB((hK) => class hL { static { i=hK(this);} });
let j=hB((hK) => class hL extends f { static { j=hK(this);} });
let k=hB((hK) => class hL extends f { static { k=hK(this);} key;u0076ar;storage;v;it;RemoveByKey(hM){ this.u0076ar.Set(this.storage.SRemoveIf((hN) => cM(this.key(hN), hM), this.u0076ar.Get()));this.ObsoleteKey(hM);} ObsoleteKey(hM){ let hN;const hO=(hN=null,[this.it.TryGetValue(hM, {get:() => hN, set:(hP) => { hN=hP;}}), hN]);if(hO[0]){ bv(hO[1]);this.it.RemoveKey(hM);} } Append(hM){ const hN=this.u0076ar.Get();const hO=this.key(hM);const hP=do_1((hQ) => cM(this.key(hQ), hO), hN);if(hP!=null&&hP.$==1)this.u0076ar.Set(this.storage.SSetAt(hP.$0, hM, hN));else this.u0076ar.Set(this.storage.SAppend(hM, hN));this.ObsoleteKey(hO);} Iter(hM){ dp(hM, this.u0076ar.Get());} UpdateBy(hM, hN){ const hO=this.u0076ar.Get();const hP=do_1((hS) => cM(this.key(hS), hN), hO);if(hP!=null&&hP.$==1){ const hQ=hP.$0;const hR=hM(bo(hO, hQ));if(hR!=null&&hR.$==1){ this.u0076ar.Set(this.storage.SSetAt(hQ, hR.$0, hO));this.ObsoleteKey(hN);} } else void 0;} GetEnumerator(){ return cI(this.u0076ar.Get());} GetEnumerator0(){ return cL(this.u0076ar.Get());} static New(hM, hN){ return new this("New", hM, hN);} static New_3(hM, hN, hO){ return new this("New_3", hM, hN, hO);} constructor(hM, hN, hO, hP){ let hQ;let hR;if(hM=="New"){ hQ=hN;hR=hO;hM="New_3";hN=hQ;hO=n.Create_1(dh(b5(hQ, hR.SInit())));hP=hR;} if(hM=="New_3"){ const hS=hN;const hT=hO;const hU=hP;super();this.key=hS;this.u0076ar=hT;this.storage=hU;this.v=R((hV) => hV.slice(), this.u0076ar.View);this.it=new bu("New_5");} } });
function l(hK, hL, hM, hN){ return{Name:hK, Amount:hL, Price:hM, LatestPrice:hN};}
function m(hK, hL){ return{Parse:hK, Write:hL};}
let n=hB((hK) => class hL extends f { static { n=hK(this);} static Create_1(hM){ return new bx(false, {s:da(hM, [])}, hM);} static { } });
function o(){ return e.totalE;}
function p(){ return e.totalG;}
function q(hK){ const hL=JSON.stringify(((cE(cF()))())(hK));globalThis.localStorage.setItem("stocks", hL);}
function r(){ const hK=globalThis.localStorage.getItem("stocks");if(hK==null)return u();else try { return u0039((hL) => l(hL.Name, hL.Amount, hL.Price, v(hL.Price)), ((cG(cF()))())(JSON.parse(hK)));} catch(hL){ return u();} }
function s(){ w();const hK=(h6) => h6.LatestPrice*h6.Amount;const hL=R((h6) => bX(hK, h6), x().v);const hM=(h6) => h6.LatestPrice*h6.Amount-h6.Price*h6.Amount;const hN=R((h6) => bX(hM, h6), x().v);const hO=R((h6) => h6>=0?"rgb(0, 255, 0)":"red", hN);const hP=Q((h6, h7) =>(h7*100/h6).toFixed(2), hL, hN);const hQ=R((h6) => h6.toFixed(2)+"$", hN);const hR=R((h6) => h6.toFixed(2)+"$", hL);const hS=c_.Convert((h6) => { const h7=h6.Amount*h6.Price;const h8=h6.LatestPrice*h6.Amount;const h9=[h7, h8, h8-h7, (it) => it.toFixed(2)];const h_=h9[2];const h$=h9[3];const ia=h$(h9[1]);const ib=h$(h9[0]);const ic=h$(h_);const id=h$(h6.LatestPrice);const ie=h$(h6.Price);const if_1=h$(h6.Amount);const ig=new bs("New_1");const ih=(ig.h.push(new c6("assetname", h6.Name)),ig);const ii=(ih.h.push(new c6("assetquantity", if_1)),ih);const ij=(ii.h.push(new c6("assetprice", ie)),ii);const ik=(ij.h.push(new c6("assetcurrentprice", id)),ij);const il=(ik.h.push(new c6("color", h_>=0?"rgb(0, 255, 0)":"red")),ik);const im=(il.h.push(new c6("assetpandl", ic)),il);const in_1=(im.h.push(new c6("assetcostbasis", ib)),im);const io=(in_1.h.push(new c6("marketvalue", ia)),in_1);const ip=(io.h.push(c8(io.k, "remove", () => io.i, () => { x().RemoveByKey(h6.Name);})),io);const iq=c9(ip.k, ip.h, []);const ir=new c4(iq[1], bh(iq[0]));let is=(ip.i=ir,ir);return is.Doc;}, x().v);const hT=new bs("New_1");const hU=(hT.h.push(new c5("portfoliotablebody", hS)),hT);const hV=(hU.h.push(new dD("assetname", A())),hU);const hW=(hV.h.push(new dC("assetquantity", z())),hV);const hX=(hW.h.push(new dC("assetprice", y())),hW);const hY=(hX.h.push(new dB("portfoliovalue", hR)),hX);const hZ=(hY.h.push(new dB("portfoliopandl", hQ)),hY);const h0=(hZ.h.push(new dB("portfoliopercent", hP)),hZ);const h1=(h0.h.push(new dB("colorpl", hO)),h0);const h2=(h1.h.push(c8(h1.k, "add", () => h1.i, () => { const h6=A();const h7=z();const h8=y();if(!dF(h6.Get())&&h7.Get()>0&&h8.Get()>0){ const h9=l(B(h6.Get()), h7.Get(), h8.Get(), v(h8.Get()));x().Append(h9);h6.Set("");h7.Set(0);h8.Set(0);} })),h1);const h3=c9(h2.k, h2.h, [["assetname", 0, null], ["assetquantity", 1, null], ["assetprice", 1, null]]);const h4=new c4(h3[1], bi(h3[0]));let h5=(h2.i=h4,h4);return h5.Doc;}
function t(){ const hK=new bs("New_1");const hL=(hK.h.push(new dD("incomegroup", I())),hK);const hM=(hL.h.push(new dC("gains", H())),hL);const hN=(hM.h.push(new dD("expensegroup", G())),hM);const hO=(hN.h.push(new dC("losses", F())),hN);const hP=(hO.h.push(new dB("income", E())),hO);const hQ=(hP.h.push(new dB("expenses", D())),hP);const hR=(hQ.h.push(new dB("balance", C())),hQ);const hS=(hR.h.push(c8(hR.k, "gainings", () => hR.i, () => { if(!dF(I().Get())&&H().Get()!==0)J();})),hR);const hT=(hS.h.push(c8(hS.k, "losings", () => hS.i, () => { if(!dF(G().Get())&&F().Get()!==0)K();})),hS);const hU=c9(hT.k, hT.h, [["incomegroup", 0, null], ["gains", 1, null], ["expensegroup", 0, null], ["losses", 1, null]]);const hV=new c4(hU[1], bj(hU[0]));let hW=(hT.i=hV,hV);return hW.Doc;}
function u(){ return e.EquityData;}
function v(hK){ return hK*(1+((L(),Math.random())-0.5)*0.2);}
function w(){ const hK=null;cu(cp(() => cq(() => true, cp(() => cr(cs(5000), () => { M();return ct();})))), null);}
function x(){ return e.EquityModel;}
function y(){ return e.stockP;}
function z(){ return e.stockA;}
function A(){ return e.stockN;}
function B(hK){ let hL;return dF(hK)?hK:(hL=hK[0],String(hL)).toUpperCase()+hK.substring(1).toLowerCase();}
function C(){ return e.balanceView;}
function D(){ return e.totalExpensesView;}
function E(){ return e.totalIncomeView;}
function F(){ return e.loss;}
function G(){ return e.expensegroup;}
function H(){ return e.gain;}
function I(){ return e.incomegroup;}
function J(){ const hK=p().Get();const hL=I().Get();const hM=H().Get();const hN=N().Get();const hO=O(hK, hL, hM, hN[0], hN[1]);N().Set([hO[0], hO[1]]);p().Set(hO[2]);I().Set("");H().Set(0);}
function K(){ const hK=o().Get();const hL=G().Get();const hM=F().Get();const hN=P().Get();const hO=O(hK, hL, hM, hN[0], hN[1]);P().Set([hO[0], hO[1]]);o().Set(hO[2]);G().Set("");F().Set(0);}
function L(){ return e.random;}
function M(){ x().Iter((hK) => { const hL=v(hK.Price);x().UpdateBy((hM) => hM.Name==hK.Name?bw(l(hM.Name, hM.Amount, hM.Price, hL)):null, hK.Name);});}
function N(){ return e.storage_i;}
function O(hK, hL, hM, hN, hO){ return[be(hN, u0038([hL])), be(hO, u0038([hM])), hK+hM];}
function P(){ return e.storage_e;}
function Q(hK, hL, hM){ return T(() => by(hK, hL(), hM()));}
function R(hK, hL){ return T(() => bz(hK, hL()));}
function S(hK, hL){ function hM(){ bA(hL(), hK, () => { co().Fork(hM);});} co().Fork(hM);}
function T(hK){ const hL={c:null, o:hK};return() => { let hM=hL.c;if(hM===null){ hM=hL.o();hL.c=hM;const hN=hM.s;if(hN!=null&&hN.$==0)hL.o=null;else bB(hM, () => { hL.c=null;});return hM;} else return hM;};}
function U(hK, hL){ return V(R(hK, hL));}
function V(hK){ return T(() => bK(hK()));}
function W(hK, hL){ return X((hM) => hM, hK, hL);}
function X(hK, hL, hM){ const hN=[new bu("New_5")];return R((hO) => { const hP=hN[0];const hQ=new bu("New_5");const hR=gi((hS) => { const hT=hK(hS);const hU=hP.ContainsKey(hT)?hP.Item(hT):hL(hS);hQ.set_Item(hT, hU);return hU;}, dh(hO));hN[0]=hQ;return hR;}, hM);}
function Y(hK){ const hL={s:db(hK)};return() => hL;}
function Z(hK, hL, hM, hN){ return T(() => bL(hK, hL(), hM(), hN()));}
function u0030(hK){ return T(() => bM(b2((hL) => hL(), hK)));}
function u0031(hK, hL){ return T(() => bN(hK(), hL()));}
function u0032(hK){ throw new Error(hK);}
function u0033(hK){ return[hK.K, hK.V];}
function u0034(hK, hL){ const hM=1+hL-hK;return hM<=0?[]:ci(hM, (hN) => hN+hK);}
function u0035(hK, hL){ return u0036(hK, bW(dh(hL)));}
function u0036(hK, hL){ return new k("New", hK, hL);}
function u0037(hK){ if(hK instanceof h)return hK;else if(hK instanceof Array)return u0038(hK);else { const hL=cI(hK);try { let hM;let hN=hL.MoveNext();if(!hN)return h.Empty;else { const hO=hC(h, {$:1});hM=hO;while(hN){ hM.$0=hL.Current;if(hL.MoveNext()){ const hP=hC(h, {$:1});hM=(hM.$1=hP,hP);} else hN=false;} hM.$1=h.Empty;return hO;} } finally { if(typeof hL=="object"&&a(hL))hL.Dispose();} } }
function u0038(hK){ let hL=h.Empty;for(let hM=bp(hK)-1, hN=0;hM>=hN;hM--)hL=h.Cons(bo(hK, hM), hL);return hL;}
function u0039(hK, hL){ let hM;let hN;let hO;if(hL.$==0)return hL;else { const hP=hC(h, {$:1});hM=hP;hN=hL;hO=true;while(hO){ hM.$0=hK(hN.$0);hN=hN.$1;if(hN.$==0)hO=false;else { const hQ=hC(h, {$:1});hM=(hM.$1=hQ,hQ);} } hM.$1=h.Empty;return hP;} }
function $(hK, hL){ let hM=hL;while(hM.$==1){ hK(bc(hM));hM=bd(hM);} }
function ba(hK, hL){ return u0038(dl(hK, hL));}
function bb(hK){ let hL=h.Empty;let hM=hK;while(hM.$==1){ hL=h.Cons(hM.$0, hL);hM=hM.$1;} return hL;}
function bc(hK){ return hK.$==1?hK.$0:bf();}
function bd(hK){ return hK.$==1?hK.$1:bf();}
function be(hK, hL){ let hM;let hN;let hO;if(hK.$==0)return hL;else if(hL.$==0)return hK;else { const hP=hC(h, {$:1});hM=hP;hN=hK;hO=true;while(hO){ hM.$0=hN.$0;hN=hN.$1;if(hN.$==0)hO=false;else { const hQ=hC(h, {$:1});hM=(hM.$1=hQ,hQ);} } hM.$1=hL;return hP;} }
function bf(){ return u0032("The input list was empty.");}
function bg(){ return cX(void 0, [[null, [[null, []]], []], [null, [[null, ["stockPortfolio"]]], []]]);}
function bh(hK){ ew("index");return hK?ex("index", bw("assetlist"), hK):void 0;}
function bi(hK){ ew("index");return hK?ex("index", bw("stockportfolio"), hK):void 0;}
function bj(hK){ ew("index");return hK?ex("index", bw("moneytracking"), hK):void 0;}
function bk(hK, hL){ const hM=n.Create_1(void 0);bl(hM, hK, hL);return hM;}
function bl(hK, hL, hM){ const hN=(hQ) => cZ(hM, c3.FromHash(hQ, bw(true)));const hO=() => bm(hN, hL);const hP=(hQ) => { if(!cM(hK.Get(), hQ))hK.Set(hQ);};hP(hO());globalThis.addEventListener("popstate", () => hP(hO()), false);globalThis.addEventListener("hashchange", () => hP(hO()), false);globalThis.document.body.addEventListener("click", (hQ) => { let hR;const hS=bn(hQ.target);if(hS==null)hR=null;else { const hT=hS.$0;hR=dG(hT, "#")?hN(hT):null;} return hR==null?null:(hP(hR.$0),hQ.preventDefault());}, false);S((hQ) => { if(!cM(hQ, hO())){ const hR=c0(hM, hQ);globalThis.history.pushState(null, null, hR);} }, hK.View);}
function bm(hK, hL){ const hM=globalThis.location.hash;const hN=hK(hM);return hN==null?((((hO) =>(hP) => hO("Failed to parse route: "+em(hP)))((hO) => { console.log(hO);}))(hM),hL):hN.$0;}
function bn(hK){ while(true){ if(hK.tagName=="A")return dA(hK.getAttribute("href"));else if(hK===globalThis.document.body)return null;else hK=hK.parentNode;} }
function bo(hK, hL){ bq(hK, hL);return hK[hL];}
function bp(hK){ return hK.dims===2?hK.length*hK.length:hK.length;}
function bq(hK, hL){ if(hL<0||hL>=hK.length)u0032("Index was outside the bounds of the array.");}
function br(hK, hL, hM){ bq(hK, hL);hK[hL]=hM;}
let bs=hB((hK) => class hL extends f { static { bs=hK(this);} i;k;h;s;static New_1(){ return new this("New_1");} constructor(hM){ if(hM=="New_1"){ let hN;super();this.i=null;this.k=(hN=c7(),String(hN));this.h=hD([]);hE(this, "s", null);} } });
let bt=hB((hK) => class hL extends f { static { bt=hK(this);} ForTextView(){ console.warn("Content hole filled with attribute data", this.Name);return null;} AddAttribute(hM, hN){ console.warn("Var hole filled with non-Var data", this.Name);} get AsChoiceView(){ console.warn("Attribute value hole filled with non-text data", this.Name);return gf("");} });
let bu=hB((hK) => class hL extends f { static { bu=hK(this);} equals;hash;count;data;set_Item(hM, hN){ this.set(hM, hN);} TryGetValue(hM, hN){ const hO=this.data[this.hash(hM)];if(hO==null)return false;else { const hP=dq((hQ) => { const hR=u0033(hQ);return this.equals.apply(null, [hR[0], hM])?bw(hR[1]):null;}, hO);return hP!=null&&hP.$==1&&(hN.set(hP.$0),true);} } RemoveKey(hM){ return this.remove(hM);} GetEnumerator(){ return cL(dr(cD(this.data)));} set(hM, hN){ const hO=this.hash(hM);const hP=this.data[hO];if(hP==null){ this.count=this.count+1;this.data[hO]=new Array({K:hM, V:hN});} else { const hQ=do_1((hR) => this.equals.apply(null, [(u0033(hR))[0], hM]), hP);if(hQ==null){ this.count=this.count+1;hP.push({K:hM, V:hN});} else hP[hQ.$0]={K:hM, V:hN};} } remove(hM){ const hN=this.hash(hM);const hO=this.data[hN];if(hO==null)return false;else { const hP=ds((hQ) =>!this.equals.apply(null, [(u0033(hQ))[0], hM]), hO);return bp(hP)<hO.length&&(this.count=this.count-1,this.data[hN]=hP,true);} } ContainsKey(hM){ const hN=this.data[this.hash(hM)];return hN==null?false:du((hO) => this.equals.apply(null, [(u0033(hO))[0], hM]), hN);} Item(hM){ return this.get(hM);} get Values(){ return new gm(this);} get Keys(){ return new gJ(this);} get(hM){ const hN=this.data[this.hash(hM)];return hN==null?eU():dx((hO) => { const hP=u0033(hO);return this.equals.apply(null, [hP[0], hM])?bw(hP[1]):null;}, hN);} static New_5(){ return new this("New_5");} static New_6(hM, hN, hO){ return new this("New_6", hM, hN, hO);} constructor(hM, hN, hO, hP){ if(hM=="New_5"){ hM="New_6";hN=[];hO=cM;hP=cP;} if(hM=="New_6"){ const hQ=hN;const hR=hO;const hS=hP;super();this.equals=hR;this.hash=hS;this.count=0;this.data=[];const hT=cI(hQ);try { while(hT.MoveNext()){ const hU=hT.Current;this.set(hU.K, hU.V);} } finally { if(typeof hT=="object"&&a(hT))hT.Dispose();} } } });
function bv(hK){ let hL;const hM=hK.s;if(hM==null||(hM!=null&&hM.$==2?(hL=hM.$1,false):hM!=null&&hM.$==3?(hL=hM.$1,false):true))void 0;else { hK.s=null;for(let hO=0, hP=bp(hL)-1;hO<=hP;hO++){ const hN=bo(hL, hO);if(typeof hN=="object")(((hQ) => { bv(hQ);})(hN));else hN();} } }
function bw(hK){ return{$:1, $0:hK};}
let bx=hB((hK) => { hF(g);return class hL extends g { static { bx=hK(this);} isConst;current;snap;view;id;get View(){ return this.view;} Get(){ return this.current;} Set(hM){ if(this.isConst)(((hN) => hN("WebSharper.UI: invalid attempt to change value of a Var after calling SetFinal"))((hN) => { console.log(hN);}));else { bv(this.snap);this.current=hM;this.snap={s:da(hM, [])};} } SetFinal(hM){ if(this.isConst)(((hN) => hN("WebSharper.UI: invalid attempt to change value of a Var after calling SetFinal"))((hN) => { console.log(hN);}));else { bv(this.snap);this.isConst=true;this.current=hM;this.snap={s:db(hM)};} } UpdateMaybe(hM){ const hN=hM(this.Get());if(hN!=null&&hN.$==1)this.Set(hN.$0);} constructor(hM, hN, hO){ super();this.isConst=hM;this.current=hO;this.snap=hN;this.view=() => this.snap;this.id=dd();} };});
function by(hK, hL, hM){ const hN=hL.s;const hO=hM.s;if(hN!=null&&hN.$==0)return hO!=null&&hO.$==0?{s:db(hK(hN.$0, hO.$0))}:bC(hK, hN.$0, hM);else if(hO!=null&&hO.$==0)return bD(hK, hO.$0, hL);else { const hP={s:dc([], [])};const hQ=() => { const hR=hP.s;if(!(hR!=null&&hR.$==0||hR!=null&&hR.$==2)){ const hS=bE(hL);const hT=bE(hM);if(hS!=null&&hS.$==1)if(hT!=null&&hT.$==1)if(hS.$0[1]&&hT.$0[1])bF(hP, hK(hS.$0[0], hT.$0[0]));else bG(hP, hK(hS.$0[0], hT.$0[0]));} };bH(hL, hQ, hP);bH(hM, hQ, hP);return hP;} }
function bz(hK, hL){ const hM=hL.s;if(hM!=null&&hM.$==0)return{s:db(hK(hM.$0))};else { const hN={s:dc([], [])};bH(hL, (hO) => { bI(hN, hL, hK(hO));}, hN);return hN;} }
function bA(hK, hL, hM){ const hN=hK.s;if(hN==null)hM();else hN!=null&&hN.$==2?(hN.$1.push(hM),hL(hN.$0)):hN!=null&&hN.$==3?(hN.$0.push(hL),hN.$1.push(hM)):hL(hN.$0);}
function bB(hK, hL){ const hM=hK.s;if(hM==null)hL();else hM!=null&&hM.$==2?hM.$1.push(hL):hM!=null&&hM.$==3?hM.$1.push(hL):void 0;}
function bC(hK, hL, hM){ return bz((hN) => hK(hL, hN), hM);}
function bD(hK, hL, hM){ return bz((hN) => hK(hN, hL), hM);}
function bE(hK){ const hL=hK.s;return hL!=null&&hL.$==0?bw([hL.$0, true]):hL!=null&&hL.$==2?bw([hL.$0, false]):null;}
function bF(hK, hL){ const hM=hK.s;if(hM!=null&&hM.$==3){ hK.s=db(hL);const hN=hM.$0;for(let hO=0, hP=bp(hN)-1;hO<=hP;hO++)(bo(hN, hO))(hL);} else void 0;}
function bG(hK, hL){ const hM=hK.s;if(hM!=null&&hM.$==3){ hK.s=da(hL, hM.$1);const hN=hM.$0;for(let hO=0, hP=bp(hN)-1;hO<=hP;hO++)(bo(hN, hO))(hL);} else void 0;}
function bH(hK, hL, hM){ const hN=hK.s;if(hN==null)bv(hM);else hN!=null&&hN.$==2?(bJ(hN.$1, hM),hL(hN.$0)):hN!=null&&hN.$==3?(hN.$0.push(hL),bJ(hN.$1, hM)):hL(hN.$0);}
function bI(hK, hL, hM){ const hN=hL.s;if(hN!=null&&hN.$==0)bF(hK, hM);else bG(hK, hM);}
function bJ(hK, hL){ hK.push(hL);if(hK.length%20===0){ const hM=hK.slice(0);e1(hK);for(let hO=0, hP=bp(hM)-1;hO<=hP;hO++){ const hN=bo(hM, hO);if(typeof hN=="object")(((hQ) => { if(hQ.s)hK.push(hQ);})(hN));else(((hQ) => { hK.push(hQ);})(hN));} } else void 0;}
function bK(hK){ const hL={s:dc([], [])};bH(hK, (hM) => { const hN=hM();bH(hN, (hO) => { let hP;const hQ=hN.s;if(hQ!=null&&hQ.$==0){ const hR=hK.s;hP=hR!=null&&hR.$==0;} else hP=false;if(hP)bF(hL, hO);else bG(hL, hO);}, hL);}, hL);return hL;}
function bL(hK, hL, hM, hN){ const hO=hL.s;const hP=hM.s;const hQ=hN.s;if(hO!=null&&hO.$==0)return hP!=null&&hP.$==0?hQ!=null&&hQ.$==0?{s:db(hK(hO.$0, hP.$0, hQ.$0))}:bP(hK, hO.$0, hP.$0, hN):hQ!=null&&hQ.$==0?bQ(hK, hO.$0, hQ.$0, hM):bR(hK, hO.$0, hM, hN);else if(hP!=null&&hP.$==0)return hQ!=null&&hQ.$==0?bS(hK, hP.$0, hQ.$0, hL):bT(hK, hP.$0, hL, hN);else if(hQ!=null&&hQ.$==0)return bU(hK, hQ.$0, hL, hM);else { const hR={s:dc([], [])};const hS=() => { const hT=hR.s;if(!(hT!=null&&hT.$==0||hT!=null&&hT.$==2)){ const hU=bE(hL);const hV=bE(hM);const hW=bE(hN);if(hU!=null&&hU.$==1)if(hV!=null&&hV.$==1)if(hW!=null&&hW.$==1)if(hU.$0[1]&&hV.$0[1]&&hW.$0[1])bF(hR, hK(hU.$0[0], hV.$0[0], hW.$0[0]));else bG(hR, hK(hU.$0[0], hV.$0[0], hW.$0[0]));} };bH(hL, hS, hR);bH(hM, hS, hR);bH(hN, hS, hR);return hR;} }
function bM(hK){ const hL=dh(hK);if(hL.length==0)return{s:db([])};else { const hM={s:dc([], [])};const hN=[bp(hL)-1];const hO=() => { if(hN[0]===0){ const hP=dv((hQ) => { const hR=hQ.s;return hR!=null&&hR.$==0?hR.$0:hR!=null&&hR.$==2?hR.$0:u0032("value not found by View.Sequence");}, hL);if(dk((hQ) => { const hR=hQ.s;return hR!=null&&hR.$==0;}, hL))bF(hM, hP);else bG(hM, hP);} else hN[0]=hN[0]-1;};dp((hP) => { bH(hP, hO, hM);}, hL);return hM;} }
function bN(hK, hL){ const hM=hK.s;const hN=hL.s;if(hM!=null&&hM.$==0)return hN!=null&&hN.$==0?{s:db(null)}:hL;else if(hN!=null&&hN.$==0)return hK;else { const hO={s:dc([], [])};const hP=() => { const hQ=hO.s;if(!(hQ!=null&&hQ.$==0||hQ!=null&&hQ.$==2)){ const hR=bE(hK);const hS=bE(hL);if(hR!=null&&hR.$==1)if(hS!=null&&hS.$==1)if(hR.$0[1]&&hS.$0[1])bF(hO, null);else bG(hO, null);} };bH(hK, hP, hO);bH(hL, hP, hO);return hO;} }
function bO(hK){ const hL=hK.s;if(hL==null)return hK;else if(hL!=null&&hL.$==2){ const hM={s:da(hL.$0, [])};bV(hK, hM);return hM;} else if(hL!=null&&hL.$==3){ const hN={s:dc([], [])};bH(hK, (hO) => { bI(hN, hK, hO);}, hN);return hN;} else return hK;}
function bP(hK, hL, hM, hN){ return bz((hO) => hK(hL, hM, hO), hN);}
function bQ(hK, hL, hM, hN){ return bz((hO) => hK(hL, hO, hM), hN);}
function bR(hK, hL, hM, hN){ return by((hO, hP) => hK(hL, hO, hP), hM, hN);}
function bS(hK, hL, hM, hN){ return bz((hO) => hK(hO, hL, hM), hN);}
function bT(hK, hL, hM, hN){ return by((hO, hP) => hK(hO, hL, hP), hM, hN);}
function bU(hK, hL, hM, hN){ return by((hO, hP) => hK(hO, hP, hL), hM, hN);}
function bV(hK, hL){ const hM=hK.s;if(hM==null)bv(hL);else hM!=null&&hM.$==2?bJ(hM.$1, hL):hM!=null&&hM.$==3?bJ(hM.$1, hL):void 0;}
function bW(hK){ return new dg(hK);}
function bX(hK, hL){ let hM=0;const hN=cI(hL);try { while(hN.MoveNext())hM=hM+hK(hN.Current);} finally { if(typeof hN=="object"&&a(hN))hN.Dispose();} return hM;}
function bY(hK, hL){ let hM=0;const hN=cI(hL);try { while(hN.MoveNext()){ hK(hM, hN.Current);hM=hM+1;} } finally { if(typeof hN=="object"&&a(hN))hN.Dispose();} }
function bZ(hK, hL){ return b6(b2(hK, hL));}
function b0(hK, hL){ return{GetEnumerator:() => { const hM=cI(hK);const hN=[true];return new eh(hM, null, (hO) => { if(hO.s.MoveNext()){ hO.c=hO.s.Current;return true;} else { const hP=hO.s;if(!cM(hP, null))hP.Dispose();hO.s=null;return hN[0]&&(hN[0]=false,hO.s=cI(hL),hO.s.MoveNext()?(hO.c=hO.s.Current,true):(hO.s.Dispose(),hO.s=null,false));} }, (hO) => { const hP=hO.s;if(!cM(hP, null))hP.Dispose();});}};}
function b1(hK){ return b7((hL, hM) =>[hL, hM], hK);}
function b2(hK, hL){ return{GetEnumerator:() => { const hM=cI(hL);return new eh(null, null, (hN) => hM.MoveNext()&&(hN.c=hK(hM.Current),true), () => { hM.Dispose();});}};}
function b3(hK, hL){ const hM=cI(hL);try { let hN=true;let hO=0;while(hN&&hM.MoveNext())if(hK(hM.Current))hN=false;else hO=hO+1;return hN?null:bw(hO);} finally { if(typeof hM=="object"&&a(hM))hM.Dispose();} }
function b4(hK, hL){ const hM=cI(hL);try { let hN=null;while(cM(hN, null)&&hM.MoveNext())hN=hK(hM.Current);return hN;} finally { if(typeof hM=="object"&&a(hM))hM.Dispose();} }
function b5(hK, hL){ return{GetEnumerator:() => { const hM=cI(hL);const hN=new en("New_3");return new eh(null, null, (hO) => { let hP;let hQ;if(hM.MoveNext()){ hP=hM.Current;hQ=hN.SAdd(hK(hP));while(!hQ&&hM.MoveNext()){ hP=hM.Current;hQ=hN.SAdd(hK(hP));} return hQ&&(hO.c=hP,true);} else return false;}, () => { hM.Dispose();});}};}
function b6(hK){ return{GetEnumerator:() => { const hL=cI(hK);function hM(hN){ while(true){ const hO=hN.s;if(cM(hO, null)){ if(hL.MoveNext()){ hN.s=cI(hL.Current);hN=hN;} else { hL.Dispose();return false;} } else if(hO.MoveNext()){ hN.c=hO.Current;return true;} else { hN.Dispose();hN.s=null;hN=hN;} } } return new eh(null, null, hM, (hN) => { const hO=hN.s;if(!cM(hO, null))hO.Dispose();if(!cM(hL, null))hL.Dispose();});}};}
function b7(hK, hL){ return b8(hK, b9((hM) => hM), hL);}
function b8(hK, hL, hM){ return{GetEnumerator:() => { const hN=cI(hL);const hO=cI(hM);return new eh(null, null, (hP) => hN.MoveNext()&&hO.MoveNext()&&(hP.c=hK(hN.Current, hO.Current),true), () => { hN.Dispose();hO.Dispose();});}};}
function b9(hK){ return{GetEnumerator:() => new eh(0, null, (hL) => { hL.c=hK(hL.s);hL.s=hL.s+1;return true;}, void 0)};}
function b_(hK){ const hL=cI(hK);try { return hL.MoveNext()?hL.Current:gE();} finally { if(typeof hL=="object"&&a(hL))hL.Dispose();} }
function b$(hK, hL, hM){ return!cc((hN, hO) =>!hK(hN, hO), hL, hM);}
function ca(hK){ return cd(() => dh(hK).slice().reverse());}
function cb(hK, hL, hM){ let hN=hL;const hO=cI(hM);try { while(hO.MoveNext())hN=hK(hN, hO.Current);return hN;} finally { if(typeof hO=="object"&&a(hO))hO.Dispose();} }
function cc(hK, hL, hM){ const hN=cI(hL);try { const hO=cI(hM);try { let hP=false;while(!hP&&hN.MoveNext()&&hO.MoveNext())hP=hK(hN.Current, hO.Current);return hP;} finally { if(typeof hO=="object"&&a(hO))hO.Dispose();} } finally { if(typeof hN=="object"&&a(hN))hN.Dispose();} }
function cd(hK){ return{GetEnumerator:() => cI(hK())};}
function ce(hK){ return b5((hL) => hL, hK);}
function cf(hK, hL){ const hM=cI(hL);try { while(hM.MoveNext())hK(hM.Current);} finally { if(typeof hM=="object"&&a(hM))hM.Dispose();} }
function cg(hK, hL){ return{GetEnumerator:() => new eh(hL, null, (hM) => { const hN=hK(hM.s);return hN==null?false:(hM.c=hN.$0[0],hM.s=hN.$0[1],true);}, void 0)};}
function ch(hK){ const hL=cI(hK);try { if(!hL.MoveNext())cj();let hM=hL.Current;while(hL.MoveNext()){ const hN=hL.Current;if(cU(hN, hM)===1)hM=hN;} return hM;} finally { if(typeof hL=="object"&&a(hL))hL.Dispose();} }
function ci(hK, hL){ return cl(hK, b9(hL));}
function cj(){ return u0032("The input sequence was empty.");}
function ck(hK, hL, hM){ const hN=cI(hL);try { const hO=cI(hM);try { let hP=0;let hQ=true;while(hQ&&hP===0)if(hN.MoveNext())hP=hO.MoveNext()?hK(hN.Current, hO.Current):1;else if(hO.MoveNext())hP=-1;else hQ=false;return hP;} finally { if(typeof hO=="object"&&a(hO))hO.Dispose();} } finally { if(typeof hN=="object"&&a(hN))hN.Dispose();} }
function cl(hK, hL){ hK<0?gI():void 0;return{GetEnumerator:() => { const hM=[cI(hL)];return new eh(0, null, (hN) => { hN.s=hN.s+1;if(hN.s>hK)return false;else { const hO=hM[0];return cM(hO, null)?gE():hO.MoveNext()?(hN.c=hO.Current,hN.s===hK?(hO.Dispose(),hM[0]=null):void 0,true):(hO.Dispose(),hM[0]=null,gE());} }, () => { const hN=hM[0];if(!cM(hN, null))hN.Dispose();});}};}
function cm(hK, hL){ return!cn((hM) =>!hK(hM), hL);}
function cn(hK, hL){ const hM=cI(hL);try { let hN=false;while(!hN&&hM.MoveNext())hN=hK(hM.Current);return hN;} finally { if(typeof hM=="object"&&a(hM))hM.Dispose();} }
function co(){ return eR.scheduler;}
function cp(hK){ return(hL) => { try {(hK())(hL);} catch(hM){ hL.k(eW(hM));} };}
function cq(hK, hL){ return hK()?cr(hL, () => cq(hK, hL)):cv();}
function cr(hK, hL){ return cw((hM) => { hK(eV((hN) => { if(hN.$==0){ const hO=hN.$0;co().Fork(() => { try {(hL(hO))(hM);} catch(hP){ hM.k(eW(hP));} });} else co().Fork(() => { hM.k(hN);});}, hM.ct));});}
function cs(hK){ return(hL) => { let hM;let hN;hM=void 0;hN=void 0;hM=setTimeout(() => { hN.Dispose();co().Fork(() => { hL.k(eX(null));});}, hK);hN=cx(hL.ct, () => { clearTimeout(hM);co().Fork(() => { cy(hL);});});};}
function ct(){ return eR.Zero;}
function cu(hK, hL){ const hM=(cz())[0];const hN=hL==null?hM:hL.$0;co().Fork(() => { if(!hN.c)hK(eV((hO) => { if(hO.$==1)cA(hO.$0);}, hN));});}
function cv(hK){ return(hL) => { hL.k(eX(hK));};}
function cw(hK){ return(hL) => { if(hL.ct.c)cy(hL);else hK(hL);};}
function cx(hK, hL){ if(hK===cB())return{Dispose(){ return null;}};else { const hM=hK.r.push(hL)-1;return{Dispose(){ return br(hK.r, hM, () => { });}};} }
function cy(hK){ hK.k(eY(new fA("New", hK.ct)));}
function cz(){ return eR.defCTS;}
function cA(hK){ console.log("WebSharper: Uncaught asynchronous exception", hK);}
function cB(){ return eR.noneCT;}
function cC(hK){ return(hL) => { const hM=[false];const hN=(hO) => { if(hM[0])u0032("A continuation provided by Async.FromContinuations was invoked multiple times");else { hM[0]=true;co().Fork(hO);} };hK((hO) => { hN(() => { hL.k(eX(hO));});}, (hO) => { hN(() => { hL.k(eW(hO));});}, (hO) => { hN(() => { hL.k(eY(hO));});});};}
function cD(hK){ let hL=[];let hM;for(var hN in hK)hL.push(hK[hN]);return hL;}
function cE(hK){ return() =>(hL) => { const hM=[];const hN=hK();$((hO) => { hM.push(hN(hO));}, hL);return hM;};}
function cF(){ return() =>(hK) => hK;}
function cG(hK){ return() =>(hL) => { const hM=hK();return ba(bp(hL), (hN) => hM(bo(hL, hN)));};}
function cH(hK){ const hL={};const hM=cI(hK);try { while(hM.MoveNext()){ const hN=hM.Current;hL[hN[0]]=hN[1];} } finally { if(typeof hM=="object"&&a(hM))hM.Dispose();} return hL;}
function cI(hK){ return hK instanceof Array?cJ(hK):cM(typeof hK, "string")?cK(hK):hK.GetEnumerator();}
function cJ(hK){ return new eh(0, null, (hL) => { const hM=hL.s;return hM<bp(hK)&&(hL.c=bo(hK, hM),hL.s=hM+1,true);}, void 0);}
function cK(hK){ return new eh(0, null, (hL) => { const hM=hL.s;return hM<hK.length&&(hL.c=hK[hM],hL.s=hM+1,true);}, void 0);}
function cL(hK){ return hK instanceof Array?cJ(hK):cM(typeof hK, "string")?cK(hK):"GetEnumerator0"in hK?hK.GetEnumerator0():hK.GetEnumerator();}
function cM(hK, hL){ if(hK===hL)return true;else { const hM=typeof hK;if(hM=="object"){ if(hK===null||hK===void 0||hL===null||hL===void 0||!cM(typeof hL, "object"))return false;else if("Equals"in hK)return hK.Equals(hL);else if("Equals"in hL)return false;else if(hK instanceof Array&&hL instanceof Array)return cN(hK, hL);else if(hK instanceof Date&&hL instanceof Date)return cO(hK, hL);else { const hN=[true];let hO;for(var hQ in hK)if(((hR) => { hN[0]=!hK.hasOwnProperty(hR)||hL.hasOwnProperty(hR)&&cM(hK[hR], hL[hR]);return!hN[0];})(hQ))break;if(hN[0]){ let hP;for(var hR in hL)if(((hS) => { hN[0]=!hL.hasOwnProperty(hS)||hK.hasOwnProperty(hS);return!hN[0];})(hR))break;} return hN[0];} } else return hM=="function"&&("$Func"in hK?hK.$Func===hL.$Func&&hK.$Target===hL.$Target:"$Invokes"in hK&&"$Invokes"in hL&&cN(hK.$Invokes, hL.$Invokes));} }
function cN(hK, hL){ let hM;let hN;if(bp(hK)===bp(hL)){ hM=true;hN=0;while(hM&&hN<bp(hK)){!cM(bo(hK, hN), bo(hL, hN))?hM=false:void 0;hN=hN+1;} return hM;} else return false;}
function cO(hK, hL){ return hK.getTime()===hL.getTime();}
function cP(hK){ const hL=typeof hK;return hL=="function"?0:hL=="boolean"?hK?1:0:hL=="number"?hK:hL=="string"?cQ(hK):hL=="object"?hK==null?0:hK instanceof Array?cR(hK):cS(hK):0;}
function cQ(hK){ let hL;if(hK===null)return 0;else { hL=5381;for(let hM=0, hN=hK.length-1;hM<=hN;hM++)hL=cT(hL, hK[hM].charCodeAt());return hL;} }
function cR(hK){ let hL=-34948909;for(let hM=0, hN=bp(hK)-1;hM<=hN;hM++)hL=cT(hL, cP(bo(hK, hM)));return hL;}
function cS(hK){ if("GetHashCode"in hK)return hK.GetHashCode();else { const hL=[0];let hM;for(var hN in hK)if(((hO) => { hL[0]=cT(cT(hL[0], cQ(hO)), cP(hK[hO]));return false;})(hN))break;return hL[0];} }
function cT(hK, hL){ return(hK<<5)+hK+hL;}
function cU(hK, hL){ if(hK===hL)return 0;else { const hM=typeof hK;switch(hM=="function"?1:hM=="boolean"?2:hM=="number"?2:hM=="string"?2:hM=="object"?3:0){ case 0:return typeof hL=="undefined"?0:-1;case 1:return u0032("Cannot compare function values.");case 2:return hK<hL?-1:1;case 3:if(hK===null)return -1;else if(hL===null)return 1;else if("CompareTo"in hK)return hK.CompareTo(hL);else if("CompareTo0"in hK)return hK.CompareTo0(hL);else if(hK instanceof Array&&hL instanceof Array)return cV(hK, hL);else if(hK instanceof Date&&hL instanceof Date)return cW(hK, hL);else { const hN=[0];let hO;for(var hQ in hK)if(((hR) =>!hK.hasOwnProperty(hR)?false:!hL.hasOwnProperty(hR)?(hN[0]=1,true):(hN[0]=cU(hK[hR], hL[hR]),hN[0]!==0))(hQ))break;if(hN[0]===0){ let hP;for(var hR in hL)if(((hS) =>!hL.hasOwnProperty(hS)?false:!hK.hasOwnProperty(hS)&&(hN[0]=-1,true))(hR))break;} return hN[0];} break;} } }
function cV(hK, hL){ let hM;let hN;if(bp(hK)<bp(hL))return -1;else if(bp(hK)>bp(hL))return 1;else { hM=0;hN=0;while(hM===0&&hN<bp(hK)){ hM=cU(bo(hK, hN), bo(hL, hN));hN=hN+1;} return hM;} }
function cW(hK, hL){ return cU(hK.getTime(), hL.getTime());}
function cX(hK, hL){ const hM=(hO, hP) => { const hQ=hK==null?{}:new hK();const hR=bo(hL, hO);const hS=hR[0];return hS!=null&&hS.$==1?hR[0].$0:(hQ.$=hO,bY((hT, hU) => { hQ["$"+String(hT)]=hU;}, hP),hQ);};const hN=dh(bZ((hO) => { const hP=hO[0];const hQ=hO[1];const hR=hQ[2];return b2((hS) =>[hP, hS[0], hS[1], hR], hQ[1]);}, b1(hL)));return m((hO) => bZ((hP) => { const hQ=hP[0];if(cY(hP[1], hO.Method)){ const hR=dz(u0038(hP[2]), hO.Segments);if(hR==null)return[];else { const hS=hR.$0;const hT=u0038(hP[3]);if(hT.$==0)return[[c3.New(hS, hO.QueryArgs, hO.FormData, hO.Method, hO.Body), hM(hQ, [])]];else { function hU(hV){ return(hW) =>(hX) => { if(hV.$==1){ const hY=hV.$1;return bZ((hZ) =>((hU(hY))(hZ[0]))(h.Cons(hZ[1], hX)), hV.$0.Parse(hW));} else return[[hW, hM(hQ, di(bb(hX)))]];};} return((hU(hT))(c3.New(hS, hO.QueryArgs, hO.FormData, hO.Method, hO.Body)))(h.Empty);} } } else return[];}, hN), (hO) => { const hP=b3((hW) => { const hX=hW[0];return hX!=null&&hX.$==1&&cM(hO, hX.$0);}, hL);const hQ=hP!=null&&hP.$==1?hP.$0:hO.$;const hR=bo(hL, hQ);const hS=hR[2];const hT=bo(hR[1], 0);const hU=[c3.Segment(u0038(hT[1]), hT[0])];if(hS.length==0)return bw(hU);else { const hV=dj((hW, hX) => hX.Write(hW), dl(bp((bo(hL, hQ))[2]), (hW) => hO["$"+String(hW)]), hS);return dk((hW) => hW!=null, hV)?bw(b0(hU, bZ((hW) => hW.$0, hV))):null;} });}
function cY(hK, hL){ return hL!=null&&hL.$==1?hK!=null&&hK.$==1?cM(hL.$0, hK.$0):true:!(hK!=null&&hK.$==1);}
function cZ(hK, hL){ return b4((hM) => hM[0].Segments.$==0?bw(hM[1]):null, hK.Parse(hL));}
function c0(hK, hL){ return"#"+c1(hK, hL);}
function c1(hK, hL){ const hM=c2(hK, hL);return hM==null?"":hM.$0.ToLink();}
function c2(hK, hL){ const hM=hK.Write(hL);return hM==null?null:bw(c3.Combine(hM.$0));}
let c3=hB((hK) => class hL { static { c3=hK(this);} Segments;QueryArgs;FormData;Method;Body;static FromHash(hM, hN){ const hO=hM.indexOf("#");if(hO===-1)return c3.Empty;else { const hP=hM.substring(hO+1);return hN!=null&&hN.$0?hP==""||hP=="/"?c3.Empty:dG(hP, "/")?c3.FromUrl(hP.substring(1), bw(true)):c3.Segment_2(hP):c3.FromUrl(hM.substring(hO), bw(false));} } static Segment(hM, hN){ return c3.New(hM, c3.Empty.QueryArgs, c3.Empty.FormData, hN, c3.Empty.Body);} static get Empty(){ return c3.New(h.Empty, new ei("New", []), new ei("New", []), null, bw(null));} static FromUrl(hM, hN){ const hO=hM.indexOf("?");const hP=hO===-1?[hM, new ei("New", [])]:[dH(hM, 0, hO), c3.ParseQuery(hM.substring(hO+1))];return c3.New(u0038(dI(hP[0], ["/"], hN!=null&&hN.$0?0:1)), hP[1], c3.Empty.FormData, c3.Empty.Method, c3.Empty.Body);} static Segment_2(hM){ return c3.New(u0038([hM]), c3.Empty.QueryArgs, c3.Empty.FormData, c3.Empty.Method, c3.Empty.Body);} static ParseQuery(hM){ return ej(dh(dn((hN) => { const hO=dI(hN, ["="], 0);return!cM(hO, null)&&hO.length===2?bw([bo(hO, 0), bo(hO, 1)]):((((hP) =>(hQ) => hP("wrong format for query argument: "+em(hQ)))((hP) => { console.log(hP);}))(hN),null);}, dI(hM, ["&"], 0))));} ToLink(){ return e4(this.Segments, this.QueryArgs);} static Combine(hM){ let hN;let hO;let hP;let hQ;const hR=dh(hM);const hS=bp(hR);if(hS===0)return c3.Empty;else if(hS===1)return bo(hR, 0);else { hN=null;hO=null;const hT=[];hP=new ei("New", []);hQ=new ei("New", []);dp((hU) => { const hV=hU.Method;if(hV!=null&&hV.$==1)hN=hV;const hW=hU.Body;if(hW==null){ } else hO=hW;hP=ek((hX, hY, hZ) => hZ.Add_1(hX, hY), hP, hU.QueryArgs);hQ=ek((hX, hY, hZ) => hZ.Add_1(hX, hY), hQ, hU.FormData);$((hX) => { hT.push(hX);}, hU.Segments);}, hR);return c3.New(u0037(hT), hP, hQ, hN, hO);} } static New(hM, hN, hO, hP, hQ){ return hC(c3, {Segments:hM, QueryArgs:hN, FormData:hO, Method:hP, Body:hQ});} });
let c4=hB((hK) => class hL extends f { static { c4=hK(this);} doc;allVars;anchorRoot;get Doc(){ return this.doc;} SetAnchorRoot(hM){ this.anchorRoot=hM;} constructor(hM, hN){ super();this.doc=hN;this.allVars=hM.$==0?hM.$0:u0032("Should not happen");this.anchorRoot=null;} });
let c5=hB((hK) => { hF(bt);return class hL extends bt { static { c5=hK(this);} name;fillWith;get Name(){ return this.name;} get Value(){ return this.fillWith;} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
let c6=hB((hK) => { hF(bt);return class hL extends bt { static { c6=hK(this);} name;fillWith;get Name(){ return this.name;} get Value(){ return this.fillWith;} get AsChoiceView(){ return gf(this.fillWith);} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
function c7(){ return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(new RegExp("[xy]", "g"), (hK) => { const hL=Math.random()*16|0;const hM=hK=="x"?hL:hL&3|8;return hM.toString(16);});}
function c8(hK, hL, hM, hN){ return new dE(hL, (hO) =>(hP) => { const hQ=hM();hQ.SetAnchorRoot(hO);return hN({Vars:hQ, Anchors:hQ, Target:hO, Event:hP});});}
function c9(hK, hL, hM){ const hN=new bu("New_5");const hO=new en("New_3");const hP=cI(hL);try { while(hP.MoveNext()){ const hQ=hP.Current;const hR=hQ.Name;hO.SAdd(hR);hN.set_Item(hR, hQ);} } finally { if(typeof hP=="object"&&a(hP))hP.Dispose();} return[b0(hL, dn((hS) => { const hT=hS[0];const hU=hS[1];const hV=hS[2];if(hO.Contains(hT))return null;else { const hW=hU===0?eo.GetOrAddHoleFor(hK, hT, () => { const hX=hV==null?null:bw(hV.$0);let hY=n.Create_1(hX==null?"":hX.$0);return new dD(hT, hY);}):hU===1?eo.GetOrAddHoleFor(hK, hT, () => { const hX=hV==null?null:bw(hV.$0);let hY=n.Create_1(hX==null?0:hX.$0);return new dC(hT, hY);}):hU===2?eo.GetOrAddHoleFor(hK, hT, () => { const hX=hV==null?null:bw(hV.$0);let hY=n.Create_1(hX==null?false:hX.$0);return new ep(hT, hY);}):hU===3?eo.GetOrAddHoleFor(hK, hT, () => { const hX=hV==null?null:bw(hV.$0);let hY=n.Create_1(hX==null?-8640000000000000:hX.$0);return new eq(hT, hY);}):hU===4?eo.GetOrAddHoleFor(hK, hT, () => new er(hT, n.Create_1([]))):hU===5?eo.GetOrAddHoleFor(hK, hT, () => new es(hT, n.Create_1(bw(globalThis.document.querySelector("[ws-dom="+hT+"]"))))):hU===6?eo.GetOrAddHoleFor(hK, hT, () => { const hX=hV==null?null:bw(hV.$0);let hY=n.Create_1(hX==null?[]:hX.$0);return new et(hT, hY);}):u0032("Invalid value type");hN.set_Item(hT, hW);return bw(hW);} }, hM)), {$:0, $0:hN}];}
let c_=hB((hK) => class hL extends f { static { c_=hK(this);} docNode;updates;static EmbedView(hM){ const hN=dR();return c_.Mk(eb(hN), R(() => { }, U((hO) => { dS(hN, hO.docNode);return hO.updates;}, hM)));} static Mk(hM, hN){ return new hL(hM, hN);} static Convert(hM, hN){ return c_.Flatten(W(hM, hN));} static RunInPlace(hM, hN, hO){ const hP=dT(hN, hO.docNode);S(fr()||fy()?fz(dU(hM, hP, hO.docNode)):() => { dV(hM, hP, hO.docNode);}, hO.updates);} static Flatten(hM){ return c_.EmbedView(R(c_.Concat, hM));} static get Empty(){ return c_.Mk(null, Y());} static Concat(hM){ return gh(c_.Empty, c_.Append, gj(hM));} static TextNode(hM){ return c_.Mk(ed(globalThis.document.createTextNode(hM)), Y());} static TextView(hM){ const hN=d4();return c_.Mk(ee(hN), R((hO) => { d5(hN, hO);}, hM));} static Append(hM, hN){ return c_.Mk(ef(hM.docNode, hN.docNode), u0031(hM.updates, hN.updates));} constructor(hM, hN){ super();this.docNode=hM;this.updates=hN;} });
function c$(hK, hL){ return hu(hK, -2147483648, 2147483647, hL);}
function da(hK, hL){ return{$:2, $0:hK, $1:hL};}
function db(hK){ return{$:0, $0:hK};}
function dc(hK, hL){ return{$:3, $0:hK, $1:hL};}
function dd(){ de(df()+1);return df();}
function de(hK){ eQ.counter=hK;}
function df(){ return eQ.counter;}
let dg=hB((hK) => class hL extends f { static { dg=hK(this);} init;SRemoveIf(hM, hN){ return ds((hO) =>!hM(hO), hN);} SInit(){ return this.init;} SSetAt(hM, hN, hO){ br(hO, hM, hN);return hO;} SAppend(hM, hN){ hN.push(hM);return hN;} constructor(hM){ super();this.init=hM;} });
function dh(hK){ if(hK instanceof Array)return hK.slice();else if(hK instanceof h)return di(hK);else { const hL=[];const hM=cI(hK);try { while(hM.MoveNext())hL.push(hM.Current);return hL;} finally { if(typeof hM=="object"&&a(hM))hM.Dispose();} } }
function di(hK){ const hL=[];let hM=hK;while(!(hM.$==0)){ hL.push(bc(hM));hM=bd(hM);} return hL;}
function dj(hK, hL, hM){ dm(hL, hM);const hN=new Array(hM.length);for(let hO=0, hP=hM.length-1;hO<=hP;hO++)hN[hO]=hK(hL[hO], hM[hO]);return hN;}
function dk(hK, hL){ let hM=true;let hN=0;while(hM&&hN<bp(hL))if(hK(hL[hN]))hN=hN+1;else hM=false;return hM;}
function dl(hK, hL){ if(hK<0)u0032("Negative size given.");else null;const hM=new Array(hK);for(let hN=0, hO=hK-1;hN<=hO;hN++)hM[hN]=hL(hN);return hM;}
function dm(hK, hL){ if(hK.length!==hL.length)u0032("The arrays have different lengths.");}
function dn(hK, hL){ const hM=[];for(let hO=0, hP=hL.length-1;hO<=hP;hO++){ const hN=hK(hL[hO]);if(hN==null){ } else hM.push(hN.$0);} return hM;}
function do_1(hK, hL){ let hM=null;let hN=0;while(hN<hL.length&&hM==null){ hK(hL[hN])?hM=bw(hN):void 0;hN=hN+1;} return hM;}
function dp(hK, hL){ for(let hM=0, hN=hL.length-1;hM<=hN;hM++)hK(hL[hM]);}
function dq(hK, hL){ let hM=null;let hN=0;while(hN<hL.length&&hM==null){ const hO=hK(hL[hN]);if(hO!=null&&hO.$==1)hM=hO;hN=hN+1;} return hM;}
function dr(hK){ return Array.prototype.concat.apply([], dh(hK));}
function ds(hK, hL){ const hM=[];for(let hN=0, hO=hL.length-1;hN<=hO;hN++)if(hK(hL[hN]))hM.push(hL[hN]);return hM;}
function dt(hK){ gG((hL) => hL[0], gF((hL, hM) =>[hM, hL], hK).sort(cU));}
function du(hK, hL){ let hM=false;let hN=0;while(!hM&&hN<bp(hL))if(hK(hL[hN]))hM=true;else hN=hN+1;return hM;}
function dv(hK, hL){ const hM=new Array(hL.length);for(let hN=0, hO=hL.length-1;hN<=hO;hN++)hM[hN]=hK(hL[hN]);return hM;}
function dw(hK, hL, hM){ let hN=hM;const hO=hL.length;for(let hP=1, hQ=hO;hP<=hQ;hP++)hN=hK(hL[hO-hP], hN);return hN;}
function dx(hK, hL){ const hM=dq(hK, hL);return hM==null?u0032("KeyNotFoundException"):hM.$0;}
function dy(hK, hL){ const hM=new Array(hK);for(let hN=0, hO=hK-1;hN<=hO;hN++)hM[hN]=hL;return hM;}
function dz(hK, hL){ let hM;switch(hK.$==1?hL.$==1?cM(hK.$0, hL.$0)?(hM=[hL.$0, hL.$1, hK.$0, hK.$1],1):2:2:0){ case 0:return bw(hL);case 1:return dz(hM[3], hM[1]);case 2:return null;} }
function dA(hK){ return hK==null?null:bw(hK);}
let dB=hB((hK) => { hF(bt);return class hL extends bt { static { dB=hK(this);} name;fillWith;get Name(){ return this.name;} ForTextView(){ return bw(this.fillWith);} get AsChoiceView(){ return gg(this.fillWith);} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
let dC=hB((hK) => { hF(bt);return class hL extends bt { static { dC=hK(this);} name;fillWith;get Name(){ return this.name;} ForTextView(){ return bw(R(String, this.fillWith.View));} AddAttribute(hM, hN){(hM(hN))(f6(this.fillWith));} get AsChoiceView(){ return gg(R(String, this.fillWith.View));} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
let dD=hB((hK) => { hF(bt);return class hL extends bt { static { dD=hK(this);} name;fillWith;get Name(){ return this.name;} ForTextView(){ return bw(this.fillWith.View);} AddAttribute(hM, hN){(hM(hN))(f7(this.fillWith));} get AsChoiceView(){ return gg(R(String, this.fillWith.View));} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
let dE=hB((hK) => { hF(bt);return class hL extends bt { static { dE=hK(this);} name;fillWith;get Name(){ return this.name;} get Value(){ return this.fillWith;} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
function dF(hK){ return hK==null||(new RegExp("^\\s*$")).test(hK);}
function dG(hK, hL){ return hK.substring(0, hL.length)==hL;}
function dH(hK, hL, hM){ return hK.substr(hL, hM);}
function dI(hK, hL, hM){ return dJ(hK, new RegExp("["+dK(hL.join(""))+"]"), hM);}
function dJ(hK, hL, hM){ return hM===1?ds((hN) => hN!=="", dL(hK, hL)):dL(hK, hL);}
function dK(hK){ return hK.replace(new RegExp("[-\\/\\\\^$*+?.()|[\\]{}]", "g"), "\\$&");}
function dL(hK, hL){ return hK.split(hL);}
function dM(hK, hL){ return dh(hL).join(hK);}
function dN(hK){ return hK==null||hK=="";}
function dO(hK, hL){ return hL.join(hK);}
function dP(hK, hL){ return cm(hK, dQ(hL));}
function dQ(hK){ return hK==null?"":hK;}
function dR(){ return{Current:null, Dirty:false};}
function dS(hK, hL){ hK.Current=hL;hK.Dirty=true;}
function dT(hK, hL){ return gn(go(), dY(hK, fQ(), hL));}
function dU(hK, hL, hM){ if(fr()){ const hN=null;return cp(() => { const hO=gp(hM);const hP=d2(hL, hO);const hQ=d1(hL, hO);return cr(fs(ft(hP, d0(hL, hO))), () => cr(dZ(hK, hL), () => cr(fs(hQ), () => { hL.PreviousNodes=hO;return cv(null);})));});} else return dZ(hK, hL);}
function dV(hK, hL, hM){ const hN=gp(hM);d3(hK, hL.Top);hL.PreviousNodes=hN;}
function dW(hK, hL){ d6(hK, hL, null);}
function dX(hK, hL){ const hM=hK.parentNode;const hN=globalThis.document.createTextNode("");hM.insertBefore(hN, hK);d7(hK, hL);return hN;}
function dY(hK, hL, hM){ dW(hK, hM);const hN=fK(hK, hL);return e0.New(hN, hM, null, hK, dd(), hG(hN.OnAfterRender));}
function dZ(hK, hL){ if(fy()){ const hM=(hN) => { requestAnimationFrame(() => { d3(hK, hL.Top);hN();});};return cC((hN, hO, hP) => hM.apply(null, [hN, hO, hP]));} else { d3(hK, hL.Top);return cv(null);} }
function d0(hK, hL){ return fw(dv((hM) => fS(hM.Attr), gt(gs(hL, gr((hM) => fR(hM.Attr), hK.PreviousNodes)))));}
function d1(hK, hL){ return fw(dv((hM) => fU(hM.Attr), gt(gs(hK.PreviousNodes, gr((hM) => fT(hM.Attr), hL)))));}
function d2(hK, hL){ const hM=(hO) => fV(hO.Attr);const hN=(hO) => gr(hM, hO);return fw(dv((hO) => fW(hO.Attr), gt(gu(hN(hK.PreviousNodes), hN(hL)))));}
function d3(hK, hL){!hK?d8(hL):void 0;d9(hL.Children);d_(hL);}
function d4(){ return{Text:globalThis.document.createTextNode(""), Dirty:false, Value:""};}
function d5(hK, hL){ hK.Value=hL;hK.Dirty=true;}
function d6(hK, hL, hM){ while(true){ if(hL!=null&&hL.$==1)return d$(hK, hL.$0.El, hM);else if(hL!=null&&hL.$==2){ const hN=hL.$0;hN.Dirty=false;hL=hN.Current;} else if(hL==null)return hM;else if(hL!=null&&hL.$==4)return d$(hK, hL.$0.Text, hM);else if(hL!=null&&hL.$==5)return d$(hK, hL.$0, hM);else if(hL!=null&&hL.$==6)return dw((hQ, hR) =>((((hS) =>(hT) =>(hU) => hT==null||hT.constructor===Object?d6(hS, hT, hU):d$(hS, hT, hU))(hK))(hQ))(hR), hL.$0.Els, hM);else { const hO=hL.$1;const hP=hL.$0;hL=hP;hM=d6(hK, hO, hM);} } }
function d7(hK, hL){ d6(hK.parentNode, hL, hK);}
function d8(hK){ function hL(hM){ function hN(hO){ while(true){ if(hO!=null&&hO.$==0){ const hP=hO.$1;const hQ=hO.$0;if(hN(hQ))return true;else hO=hP;} else if(hO!=null&&hO.$==2){ const hR=hO.$0;if(hR.Dirty)return true;else hO=hR.Current;} else if(hO!=null&&hO.$==6){ const hS=hO.$0;return hS.Dirty||du(hL, hS.Holes);} else return false;} } return hN(hM.Children);} fZ(hK.El, hK.Attr);if(hL(hK))ea(hK);}
function d9(hK){ while(true){ if(hK!=null&&hK.$==1)return d3(false, hK.$0);else if(hK!=null&&hK.$==2){ const hL=hK.$0;hK=hL.Current;} else if(hK==null)return null;else if(hK!=null&&hK.$==5)return null;else if(hK!=null&&hK.$==4){ const hM=hK.$0;return hM.Dirty?(hM.Text.nodeValue=hM.Value,hM.Dirty=false):null;} else if(hK!=null&&hK.$==6){ const hN=hK.$0;dp((hQ) => { d3(false, hQ);}, hN.Holes);dp((hQ) => { fZ(hQ[0], hQ[1]);}, hN.Attrs);return d_(hN);} else { const hO=hK.$1;const hP=hK.$0;d9(hP);hK=hO;} } }
function d_(hK){ const hL=hG(hK.Render);if(hL!=null&&hL.$==1){ hL.$0(hK.El);hE(hK, "Render", null);} }
function d$(hK, hL, hM){ fo(hK, hM, hL);return hL;}
function ea(hK){ const hL=hK.El;function hM(hQ, hR){ while(true){ if(hQ!=null&&hQ.$==1)return hQ.$0.El;else if(hQ!=null&&hQ.$==2){ const hS=hQ.$0;if(hS.Dirty){ hS.Dirty=false;return d6(hL, hS.Current, hR);} else hQ=hS.Current;} else if(hQ==null)return hR;else if(hQ!=null&&hQ.$==4)return hQ.$0.Text;else if(hQ!=null&&hQ.$==5)return hQ.$0;else if(hQ!=null&&hQ.$==6){ const hT=hQ.$0;if(hT.Dirty)hT.Dirty=false;return dw((hW, hX) => hW==null||hW.constructor===Object?hM(hW, hX):hW, hT.Els, hR);} else { const hU=hQ.$1;const hV=hQ.$0;hQ=hV;hR=hM(hU, hR);} } } const hN=hK.El;hp((hQ) => { fp(hN, hQ);}, ho(hq(hK), hn(hK.El, hG(hK.Delimiters))));let hO=hK.Children;const hP=hG(hK.Delimiters);hM(hO, hP!=null&&hP.$==1?hP.$0[1]:null);}
function eb(hK){ return{$:2, $0:hK};}
function ec(hK){ return{$:6, $0:hK};}
function ed(hK){ return{$:5, $0:hK};}
function ee(hK){ return{$:4, $0:hK};}
function ef(hK, hL){ return{$:0, $0:hK, $1:hL};}
let eg=hB((hK) => class hL extends f { static { eg=hK(this);} idle;robin;Fork(hM){ this.robin.push(hM);this.idle?(this.idle=false,setTimeout(() => { this.tick();}, 0)):void 0;} tick(){ const hM=Date.now();let hN=true;while(hN)if(this.robin.length===0){ this.idle=true;hN=false;} else {(this.robin.shift())();Date.now()-hM>40?(setTimeout(() => { this.tick();}, 0),hN=false):void 0;} } constructor(){ super();this.idle=true;this.robin=[];} });
let eh=hB((hK) => class hL extends f { static { eh=hK(this);} s;c;n;d;e;MoveNext(){ const hM=this.n(this);this.e=hM?1:2;return hM;} get Current(){ return this.e===1?this.c:this.e===0?u0032("Enumeration has not started. Call MoveNext."):u0032("Enumeration already finished.");} Dispose(){ if(this.d)this.d(this);} constructor(hM, hN, hO, hP){ super();this.s=hM;this.c=hN;this.n=hO;this.d=hP;this.e=0;} });
let ei=hB((hK) => class hL extends f { static { ei=hK(this);} tree;GetEnumerator(){ return cI(b2((hM) =>({K:hM.Key, V:hM.Value}), fD(false, this.tree)));} Equals(hM){ return this.Count===hM.Count&&b$(cM, this, hM);} get Count(){ const hM=this.tree;return hM==null?0:hM.Count;} Add_1(hM, hN){ return new ei("New_1", fG(eT.New(hM, hN), this.tree));} get IsEmpty(){ return this.tree==null;} GetHashCode(){ return cP(dh(this));} get Tree(){ return this.tree;} CompareTo0(hM){ return ck(cU, this, hM);} static New(hM){ return new this("New", hM);} static New_1(hM){ return new this("New_1", hM);} constructor(hM, hN){ let hO;if(hM=="New"){ hO=hN;hM="New_1";hN=e3(hO);} if(hM=="New_1"){ const hP=hN;super();this.tree=hP;} } });
function ej(hK){ return new ei("New_1", fC(b2((hL) => eT.New(hL[0], hL[1]), hK)));}
function ek(hK, hL, hM){ return cb((hN, hO) => hK(hO.Key, hO.Value, hN), hM, fD(true, hL.Tree));}
function el(hK){ return b2((hL) =>[hL.Key, hL.Value], fD(false, hK.Tree));}
function em(hK){ return hK==null?"":hK;}
let en=hB((hK) => class hL extends f { static { en=hK(this);} equals;hash;data;count;SAdd(hM){ return this.add(hM);} Contains(hM){ const hN=this.data[this.hash(hM)];return hN==null?false:this.arrContains(hM, hN);} add(hM){ const hN=this.hash(hM);const hO=this.data[hN];return hO==null?(this.data[hN]=[hM],this.count=this.count+1,true):this.arrContains(hM, hO)?false:(hO.push(hM),this.count=this.count+1,true);} arrContains(hM, hN){ let hO=true;let hP=0;const hQ=hN.length;while(hO&&hP<hQ)if(this.equals.apply(null, [hN[hP], hM]))hO=false;else hP=hP+1;return!hO;} GetEnumerator(){ return cI(gK(this.data));} ExceptWith(hM){ const hN=cI(hM);try { while(hN.MoveNext())this.Remove(hN.Current);} finally { if(typeof hN=="object"&&a(hN))hN.Dispose();} } get Count(){ return this.count;} IntersectWith(hM){ const hN=new en("New_4", hM, this.equals, this.hash);const hO=gK(this.data);for(let hQ=0, hR=hO.length-1;hQ<=hR;hQ++){ const hP=hO[hQ];if(!hN.Contains(hP))this.Remove(hP);} } Remove(hM){ const hN=this.data[this.hash(hM)];return hN==null?false:this.arrRemove(hM, hN)&&(this.count=this.count-1,true);} CopyTo(hM, hN){ const hO=gK(this.data);for(let hP=0, hQ=hO.length-1;hP<=hQ;hP++)br(hM, hP+hN, hO[hP]);} arrRemove(hM, hN){ let hO=true;let hP=0;const hQ=hN.length;while(hO&&hP<hQ)if(this.equals.apply(null, [hN[hP], hM])){ hN.splice(hP, 1);hO=false;} else hP=hP+1;return!hO;} static New_3(){ return new this("New_3");} static New_4(hM, hN, hO){ return new this("New_4", hM, hN, hO);} static New_2(hM){ return new this("New_2", hM);} constructor(hM, hN, hO, hP){ if(hM=="New_3"){ hM="New_4";hN=[];hO=cM;hP=cP;} let hQ;if(hM=="New_2"){ hQ=hN;hM="New_4";hN=hQ;hO=cM;hP=cP;} if(hM=="New_4"){ const hR=hN;const hS=hO;const hT=hP;super();this.equals=hS;this.hash=hT;this.data=[];this.count=0;const hU=cI(hR);try { while(hU.MoveNext())this.add(hU.Current);} finally { if(typeof hU=="object"&&a(hU))hU.Dispose();} } } });
let eo=hB((hK) => class hL extends f { static { eo=hK(this);} static init;id;vars;static initialized;static instances;static GetOrAddHoleFor(hM, hN, hO){ let hP;const hQ=eo.GetHolesFor(hM);const hR=(hP=null,[hQ.TryGetValue(hN, {get:() => hP, set:(hT) => { hP=hT;}}), hP]);if(hR[0])return hR[1];else { const hS=hO();hQ.set_Item(hN, hS);return hS;} } static GetHolesFor(hM){ let hN;const hO=(hN=null,[eo.initialized.TryGetValue(hM, {get:() => hN, set:(hQ) => { hN=hQ;}}), hN]);if(hO[0])return hO[1];else { const hP=new bu("New_5");eo.initialized.set_Item(hM, hP);return hP;} } static { eo.initialized=new bu("New_5");eo.instances=new bu("New_5");} });
let ep=hB((hK) => { hF(bt);return class hL extends bt { static { ep=hK(this);} name;fillWith;get Name(){ return this.name;} ForTextView(){ return bw(R(String, this.fillWith.View));} AddAttribute(hM, hN){(hM(hN))(f8(this.fillWith));} get AsChoiceView(){ return gg(R(String, this.fillWith.View));} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
let eq=hB((hK) => { hF(bt);return class hL extends bt { static { eq=hK(this);} name;fillWith;get Name(){ return this.name;} ForTextView(){ return bw(R((hM) =>(new Date(hM)).toLocaleString(), this.fillWith.View));} AddAttribute(hM, hN){(hM(hN))(f9(this.fillWith));} get AsChoiceView(){ return gg(R((hM) =>(new Date(hM)).toLocaleString(), this.fillWith.View));} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
let er=hB((hK) => { hF(bt);return class hL extends bt { static { er=hK(this);} name;fillWith;get Name(){ return this.name;} ForTextView(){ return bw(R(String, this.fillWith.View));} AddAttribute(hM, hN){(hM(hN))(f_(this.fillWith));} get AsChoiceView(){ return gg(R(String, this.fillWith.View));} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
let es=hB((hK) => { hF(bt);return class hL extends bt { static { es=hK(this);} name;fillWith;get Name(){ return this.name;} get Value(){ return this.fillWith;} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
let et=hB((hK) => { hF(bt);return class hL extends bt { static { et=hK(this);} name;fillWith;get Name(){ return this.name;} ForTextView(){ return bw(R((hM) => dM(",", hM), this.fillWith.View));} AddAttribute(hM, hN){(hM(hN))(f$(this.fillWith));} get AsChoiceView(){ return gg(R(String, this.fillWith.View));} constructor(hM, hN){ super();this.name=hM;this.fillWith=hN;} };});
let eu=hB((hK) => class hL extends f { static { eu=hK(this);} });
function ev(hK){ if(ey()==null){ ew("");ez("", null, globalThis.document.body, null);const hL=eA(globalThis.document.body, hK);const hM=globalThis.document.body;(((hO) => { c_.RunInPlace(true, hM, hO);})(hL));const hN=hL;eB(bw(hN));return hN;} else return ey().$0;}
function ew(hK){!eC()?(eD(true),eE(globalThis.document.body, "")):void 0;eF().set_Item(hK, eG(""));}
function ex(hK, hL, hM){ let hN;const hO=(hN=null,[eG(hK).TryGetValue(hL==null?"":hL.$0, {get:() => hN, set:(hP) => { hN=hP;}}), hN]);return hO[0]?eA(hO[1].cloneNode(true), hM):(console.warn("Local template doesn't exist", hL),c_.Empty);}
function ey(){ return e7.RenderedFullDocTemplate;}
function ez(hK, hL, hM, hN){ const hO=new en("New_3");function hP(hW, hX){ while(true)switch(hW){ case 0:if(hX!==null){ const hY=hX.nextSibling;if(cM(hX.nodeType, Node.TEXT_NODE))e8(hX);else if(cM(hX.nodeType, Node.ELEMENT_NODE))hR(hX);hX=hY;} else return null;break;case 1:const hZ=fe(hX.nodeName, bw(3), null).toLowerCase();const h0=hZ.indexOf(".");const h1=h0===-1?[hK, hZ]:[fe(hZ, null, bw(h0-1)), fe(hZ, bw(h0+1), null)];const h2=h1[1];const h3=h1[0];if(h3!=""&&!eF().ContainsKey(h3))return e9(h2);else { if(h3==""&&hN!=null)hN.$0(h2);const h4=eF().Item(h3);if(!h4.ContainsKey(h2))return e9(h2);else { const h5=h4.Item(h2);const h6=h5.cloneNode(true);const h7=new en("New_3");const h8=new bu("New_5");const h9=hX.attributes;for(let ih=0, ii=h9.length-1;ih<=ii;ih++){ const h_=h9.item(ih).name.toLowerCase();const h$=h9.item(ih).nodeValue;let ia=h$==""?h_:h$.toLowerCase();h8.set_Item(h_, ia);if(!h7.SAdd(h_))console.warn("Hole mapped twice", h_);} for(let ij=0, ik=hX.childNodes.length-1;ij<=ik;ij++){ const ib=hX.childNodes[ij];if(cM(ib.nodeType, Node.ELEMENT_NODE))if(!h7.SAdd(ib.nodeName.toLowerCase()))console.warn("Hole filled twice", h2);} const ic=hX.childNodes.length===1&&cM(hX.firstChild.nodeType, Node.TEXT_NODE);if(ic){ const id=e_(h6, hX.firstChild.textContent, h2);const ie=((il) =>(im) => il.SAdd(im))(h7);let if_1=((il) =>(im) => { if(im!=null)il(im.$0);})((il) => { ie(il);});if_1(id);} e$(h6, h7);if(!ic){ for(let il=0, im=hX.childNodes.length-1;il<=im;il++){ const ig=hX.childNodes[il];if(cM(ig.nodeType, Node.ELEMENT_NODE))if(ig.hasAttributes())fa(h6, ig);else hQ(h6, ig);} } fb(h6, h8);fc(h6, hX.parentNode, hX);hX.parentNode.removeChild(hX);return;} } break;} } function hQ(hW, hX){ const hY=hX.nodeName.toLowerCase();const hZ=(h3, h4) => { if(hY=="title"&&hX.hasChildNodes()){ const h5=ff(hX.textContent);hX.removeChild(hX.firstChild);while(h5.hasChildNodes())hX.appendChild(h5.firstChild);} hR(hX);return fc(hX, h3, h4);};eH(hW, "[ws-attr-holes]", (h3) => { const h4=dI(h3.getAttribute("ws-attr-holes"), [" "], 1);for(let h8=0, h9=h4.length-1;h8<=h9;h8++){ const h5=bo(h4, h8);let h6=new RegExp("\\${"+hY+"}", "ig");let h7=h3.getAttribute(h5).replace(h6, hX.textContent);h3.setAttribute(h5, h7);} });const h0=hW.querySelector("[ws-hole="+hY+"]");if(cM(h0, null)){ const h1=hW.querySelector("[ws-replace="+hY+"]");if(cM(h1, null)){ const h2=hW.querySelector("slot[name="+hY+"]");return hW.tagName.toLowerCase()=="template"?(hZ(h2.parentNode, h2),void h2.parentNode.removeChild(h2)):null;} else { hZ(h1.parentNode, h1);h1.parentNode.removeChild(h1);return;} } else { while(h0.hasChildNodes())h0.removeChild(h0.lastChild);h0.removeAttribute("ws-hole");return hZ(h0, null);} } function hR(hW){ if(!hW.hasAttribute("ws-preserve"))if(dG(hW.nodeName.toLowerCase(), "ws-"))hT(hW);else { fd(hW);hS(hW.firstChild);} } function hS(hW){ return hP(0, hW);} function hT(hW){ return hP(1, hW);} function hU(hW){ while(true){ const hX=hW.querySelector("[ws-template]");if(cM(hX, null)){ const hY=hW.querySelector("[ws-children-template]");if(cM(hY, null)){ const hZ=hW.querySelectorAll("template[id]");for(let h5=1, h6=hZ.length-1;h5<=h6;h5++){ const h0=hZ[h5];if(hO.Contains(h0)){ } else { ez(hK, bw(h0.getAttribute("id")), h0, null);hO.SAdd(h0);} } const h1=hW.querySelectorAll("template[name]");for(let h7=1, h8=h1.length-1;h7<=h8;h7++){ const h2=h1[h7];if(hO.Contains(h2)){ } else { ez(hK, bw(h2.getAttribute("name")), h2, null);hO.SAdd(h2);} } return null;} else { const h3=hY.getAttribute("ws-children-template");hY.removeAttribute("ws-children-template");ez(hK, bw(h3), hY, null);hW=hW;} } else { const h4=hX.getAttribute("ws-template");(eI(hK, bw(h4), hX))(null);hW=hW;} } } const hV=(hL==null?"":hL.$0).toLowerCase();eG(hK).set_Item(hV, hM);if(hM.hasChildNodes()){ hU(hM);hS(hM.firstChild);} }
function eA(hK, hL){ let hM;const hN=eJ(hK, b0(hL, eK().Values));const hO=hN[1];const hP=hN[0];const hQ=hP.Els;return!cM(hQ, null)&&hQ.length===1&&(bo(hQ, 0)instanceof Node&&(cM(bo(hQ, 0).nodeType, Node.ELEMENT_NODE)&&(hM=bo(hQ, 0),true)))?fq.TreeNode(hP, hO):c_.Mk(ec(hP), hO);}
function eB(hK){ e7.RenderedFullDocTemplate=hK;}
function eC(){ return e7.LocalTemplatesLoaded;}
function eD(hK){ e7.LocalTemplatesLoaded=hK;}
function eE(hK, hL){ const hM=eG(hL);const hN=new bu("New_5");const hO=hK.querySelectorAll("[ws-template]");for(let h0=0, h1=hO.length-1;h0<=h1;h0++){ const hP=hO[h0];const hQ=hP.getAttribute("ws-template").toLowerCase();hP.removeAttribute("ws-template");hN.set_Item(hQ, eL(hP));} const hR=hK.querySelectorAll("[ws-children-template]");for(let h2=0, h3=hR.length-1;h2<=h3;h2++){ const hS=hR[h2];const hT=hS.getAttribute("ws-children-template").toLowerCase();hS.removeAttribute("ws-children-template");hN.set_Item(hT, eM(hS));} const hU=hK.querySelectorAll("template[id]");for(let h4=0, h5=hU.length-1;h4<=h5;h4++){ const hV=hU[h4];hN.set_Item(hV.getAttribute("id").toLowerCase(), eN(hV));} const hW=hK.querySelectorAll("template[name]");for(let h6=0, h7=hW.length-1;h6<=h7;h6++){ const hX=hW[h6];hN.set_Item(hX.getAttribute("name").toLowerCase(), eN(hX));} const hY=new en("New_3");function hZ(h8){ if(!hM.ContainsKey(h8)){ let h9;const h_=(h9=null,[hN.TryGetValue(h8, {get:() => h9, set:(h$) => { h9=h$;}}), h9]);if(h_[0]){ hY.SAdd(h8);hN.RemoveKey(h8);ez(hL, bw(h8), h_[1], bw(hZ));} else console.warn(hY.Contains(h8)?"Encountered loop when instantiating "+h8:"Local template does not exist: "+h8);} } while(hN.count>0)hZ(b_(hN.Keys));}
function eF(){ return e7.LoadedTemplates;}
function eG(hK){ let hL;const hM=(hL=null,[eF().TryGetValue(hK, {get:() => hL, set:(hO) => { hL=hO;}}), hL]);if(hM[0])return hM[1];else { const hN=new bu("New_5");eF().set_Item(hK, hN);return hN;} }
function eH(hK, hL, hM){ fl(hK, hL, (hN) => { if(hN.closest("[ws-preserve]")==null)hM(hN);});}
function eI(hK, hL, hM){ const hN=eL(hM);return(hO) => { ez(hK, hL, hN, hO);};}
function eJ(hK, hL){ let hM;const hN=[];const hO=[];const hP=[];const hQ=[];const hR=new bu("New_5");const hS=cI(hL);try { while(hS.MoveNext()){ const hT=hS.Current;hR.set_Item(hT.Name, hT);} } finally { if(typeof hS=="object"&&a(hS))hS.Dispose();} const hU=fm(hK);const hV=(h2, h3) => { const h4=fK(h2, h3);hO.push(fL(h4));hP.push([h2, h4]);const h5=hG(h4.OnAfterRender);if(h5==null)return null;else { const h6=h5.$0;hQ.push(() => { h6(h2);});return;} };const hW=(h2) => { let h3;const h4=(h3=null,[hR.TryGetValue(h2, {get:() => h3, set:(h7) => { h3=h7;}}), h3]);if(h4[0]){ const h5=h4[1];if(h5 instanceof c5)return bw(h5.Value);else if(h5 instanceof c6)return bw(c_.TextNode(h5.Value));else { const h6=h5.ForTextView();return h6==null?null:bw(c_.TextView(h6.$0));} } else return null;};eH(hK, "[ws-hole]", (h2) => { const h3=h2.getAttribute("ws-hole");h2.removeAttribute("ws-hole");while(h2.hasChildNodes())h2.removeChild(h2.lastChild);const h4=hW(h3);if(h4!=null&&h4.$==1){ const h5=h4.$0;dW(h2, h5.docNode);hN.push(e0.New(fM(h2), h5.docNode, null, h2, dd(), null));hO.push(h5.updates);} });eH(hK, "[ws-replace]", (h2) => { const h3=hW(h2.getAttribute("ws-replace"));if(h3!=null&&h3.$==1){ const h4=h3.$0;const h5=h2.parentNode;const h6=globalThis.document.createTextNode("");h5.replaceChild(h6, h2);const h7=dX(h6, h4.docNode);const h8=do_1((h9) => h2===h9, hU);if(h8==null){ } else br(hU, h8.$0, h4.docNode);hN.push(e0.New(fM(h5), h4.docNode, bw([h7, h6]), h5, dd(), null));hO.push(h4.updates);} });let hX=false;eH(hK, "slot", (h2) => { const h3=h2.getAttribute("name");const h4=h3==""||h3==null?"default":h3.toLowerCase();if(hX&&h4=="default"||!cM(hK.parentElement, null)){ } else { while(h2.hasChildNodes())h2.removeChild(h2.lastChild);if(h4=="default")hX=true;const h5=hW(h4);if(h5!=null&&h5.$==1){ const h6=h5.$0;dW(h2, h6.docNode);hN.push(e0.New(fM(h2), h6.docNode, null, h2, dd(), null));hO.push(h6.updates);} } });eH(hK, "[ws-attr]", (h2) => { let h3;const h4=h2.getAttribute("ws-attr");h2.removeAttribute("ws-attr");const h5=(h3=null,[hR.TryGetValue(h4, {get:() => h3, set:(h7) => { h3=h7;}}), h3]);if(h5[0]){ const h6=h5[1];if(h6 instanceof f1)hV(h2, h6.Value);else console.warn("Attribute hole filled with non-attribute data", h4);} });eH(hK, "[ws-on]", (h2) => { hV(h2, gc.Concat(dn((h3) => { let h4;const h5=dI(h3, [":"], 1);const h6=(h4=null,[hR.TryGetValue(bo(h5, 1), {get:() => h4, set:(h8) => { h4=h8;}}), h4]);if(h6[0]){ const h7=h6[1];return h7 instanceof f2?bw(f3(bo(h5, 0), h7.Value)):h7 instanceof dE?bw(gc.Handler(bo(h5, 0), h7.Value)):(console.warn("Event hole on"+bo(h5, 0)+" filled with non-event data", bo(h5, 1)),null);} else return null;}, dI(h2.getAttribute("ws-on"), [" "], 1))));h2.removeAttribute("ws-on");});eH(hK, "[ws-onafterrender]", (h2) => { let h3;const h4=h2.getAttribute("ws-onafterrender");const h5=(h3=null,[hR.TryGetValue(h4, {get:() => h3, set:(h7) => { h3=h7;}}), h3]);if(h5[0]){ const h6=h5[1];if(h6 instanceof gd){ h2.removeAttribute("ws-onafterrender");hV(h2, f4(h6.Value));} else if(h6 instanceof ge){ h2.removeAttribute("ws-onafterrender");hV(h2, f4(h6.Value));} else console.warn("onafterrender hole filled with non-onafterrender data", h4);} });eH(hK, "[ws-var]", (h2) => { let h3;const h4=h2.getAttribute("ws-var");h2.removeAttribute("ws-var");const h5=(h3=null,[hR.TryGetValue(h4, {get:() => h3, set:(h6) => { h3=h6;}}), h3]);if(h5[0])h5[1].AddAttribute((h6) =>(h7) => hV(h6, h7), h2);});const hY=() => { eP("[ws-dom]", (h2) => { let h3;let h4;let h5;const h6=(h3=null,[hR.TryGetValue(h2.getAttribute("ws-dom").toLowerCase(), {get:() => h3, set:(h_) => { h3=h_;}}), h3]);if(h6[0]){ const h7=h6[1];if(h7 instanceof es){ const h8=h7.Value;h2.removeAttribute("ws-dom");h4=h2;const h9=new MutationObserver((h_, h$) => { dp((ia) => { ia.removedNodes.forEach(hH((ib) => ib[0]===h4&&ia.addedNodes.length!==1?(h8.SetFinal(null),h$.disconnect()):null), null);}, h_);});if(h2.parentElement!==null)h9.observe(h2.parentElement, (h5={},h5.childList=true,h5));h8.Set(bw(h2));S((h_) => { if(h_!=null&&h_.$==1){ const h$=h_.$0;if(h4===h$){ } else { h4.replaceWith(h$);h4=h$;} } else { h4.remove();h9.disconnect();} }, h8.View);} } });};eH(hK, "[ws-attr-holes]", (h2) => { const h3=new RegExp(eO(), "g");const h4=dI(h2.getAttribute("ws-attr-holes"), [" "], 1);h2.removeAttribute("ws-attr-holes");for(let h5=0, h6=h4.length-1;h5<=h6;h5++)((() => { let h7;const h8=bo(h4, h5);const h9=h2.getAttribute(h8);let h_=null;let h$=0;const ia=[];while(h_=h3.exec(h9),h_!==null){ const ib=fe(h9, bw(h$), bw(h3.lastIndex-bo(h_, 0).length-1));h$=h3.lastIndex;ia.push([ib, bo(h_, 1)]);} const ic=fe(h9, bw(h$), null);h3.lastIndex=0;const id=dw((ii, ij) =>(((ik) => { const il=ik[0];const im=ik[1];return(in_1) => { let io;const ip=in_1[0];const iq=in_1[1];const ir=(io=null,[hR.TryGetValue(im, {get:() => io, set:(it) => { io=it;}}), io]);const is=ir[0]?ir[1].AsChoiceView:gf("");return is.$==1?[il, h.Cons(ip==""?is.$0:R((it) => it+ip, is.$0), iq)]:[il+is.$0+ip, iq];};})(ii))(ij), ia, [ic, h.Empty]);if(id[1].$==1){ if(id[1].$1.$==1){ if(id[1].$1.$1.$==1){ if(id[1].$1.$1.$1.$==0){ const ie=id[0];h7=f5(h8, Z((ii, ij, ik) => ie+ii+ij+ik, id[1].$0, id[1].$1.$0, id[1].$1.$1.$0));} else { const if_1=id[0];h7=f5(h8, R((ii) => if_1+dM("", ii), u0030(id[1])));} } else { const ig=id[0];h7=f5(h8, Q((ii, ij) => ig+ii+ij, id[1].$0, id[1].$1.$0));} } else if(id[0]=="")h7=f5(h8, id[1].$0);else { const ih=id[0];h7=f5(h8, R((ii) => ih+ii, id[1].$0));} } else h7=gc.Create(h8, id[0]);return hV(h2, h7);})());});const hZ=hQ.length==0?bw(() => { hY();}):bw((h2) => { hY();dp((h3) => { h3(h2);}, hQ);});const h0=!cM(hU, null)&&hU.length===1&&(bo(hU, 0)instanceof Node&&(bo(hU, 0)instanceof Element&&(hM=bo(hU, 0),true)))?bw(hM):null;let h1=hI({Els:hU, Dirty:true, Holes:hN, Attrs:hP, Render:hZ?hZ.$0:void 0, El:h0?h0.$0:void 0}, ["Render", "El"]);return[h1, gh(Y(), u0031, hO)];}
function eK(){ return e7.GlobalHoles;}
function eL(hK){ hK.removeAttribute("ws-template");const hL=hK.getAttribute("ws-replace");if(hL==null){ } else { hK.removeAttribute("ws-replace");const hM=hK.parentNode;if(cM(hM, null)){ } else { const hN=globalThis.document.createElement(hK.tagName);hN.setAttribute("ws-replace", hL);hM.replaceChild(hN, hK);} } const hO=globalThis.document.createElement("div");hO.appendChild(hK);return hO;}
function eM(hK){ const hL=globalThis.document.createElement("div");while(hK.hasChildNodes())hL.appendChild(hK.firstChild);return hL;}
function eN(hK){ const hL=globalThis.document.createElement("div");const hM=hK.content;for(let hN=0, hO=hM.childNodes.length-1;hN<=hO;hN++)hL.appendChild(hM.childNodes[hN].cloneNode(true));return hL;}
function eO(){ return e7.TextHoleRE;}
function eP(hK, hL){ fn(hK, (hM) => { if(hM.closest("[ws-preserve]")==null)hL(hM);});}
let eQ=hB((hK) => class hL { static { eQ=hK(this);} static counter;static { this.counter=0;} });
let eR=hB((hK) => class hL { static { eR=hK(this);} static GetCT;static Zero;static defCTS;static scheduler;static noneCT;static { this.noneCT=eZ(false, []);this.scheduler=new eg();this.defCTS=[new e2()];this.Zero=cv();this.GetCT=(hM) => { hM.k(eX(hM.ct));};} });
function eS(hK, hL, hM, hN, hO){ return{Node:hK, Left:hL, Right:hM, Height:hN, Count:hO};}
let eT=hB((hK) => class hL { static { eT=hK(this);} Key;Value;Equals(hM){ return cM(this.Key, hM.Key);} GetHashCode(){ return cP(this.Key);} CompareTo0(hM){ return cU(this.Key, hM.Key);} static New(hM, hN){ return hC(eT, {Key:hM, Value:hN});} });
function eU(){ throw new gR("New");}
function eV(hK, hL){ return{k:hK, ct:hL};}
function eW(hK){ return{$:1, $0:hK};}
function eX(hK){ return{$:0, $0:hK};}
function eY(hK){ return{$:2, $0:hK};}
function eZ(hK, hL){ return{c:hK, r:hL};}
let e0=hB((hK) => class hL { static { e0=hK(this);} Attr;Children;Delimiters;El;ElKey;Render;Equals(hM){ return this.ElKey===hM.ElKey;} GetHashCode(){ return this.ElKey;} static New(hM, hN, hO, hP, hQ, hR){ const hS={Attr:hM, Children:hN, El:hP, ElKey:hQ};let hT=(hE(hS, "Delimiters", hO),hE(hS, "Render", hR),hS);return hC(e0, hT);} });
function e1(hK){ hK.splice(0, bp(hK));}
let e2=hB((hK) => class hL extends f { static { e2=hK(this);} init;c;pending;r;constructor(){ super();this.c=false;this.pending=null;this.r=[];this.init=1;} });
function e3(hK){ const hL=dh(b2((hM) => eT.New(hM[0], hM[1]), b5((hM) => hM[0], ca(hK))));dt(hL);return fE(hL, 0, hL.length-1);}
function e4(hK, hL){ const hM=hL.IsEmpty?"":"?"+e6(hL);return"/"+e5(hK)+hM;}
function e5(hK){ let hL;const hM=[];hL=true;$((hN) => { if(!dN(hN)){ hL?hL=false:hM.push("/");hM.push(hN);} }, hK);return dO("", dh(hM));}
function e6(hK){ return dM("&", b2((hL) => hL[0]+"="+hL[1], el(hK)));}
let e7=hB((hK) => class hL { static { e7=hK(this);} static RenderedFullDocTemplate;static TextHoleRE;static GlobalHoles;static LocalTemplatesLoaded;static LoadedTemplates;static { this.LoadedTemplates=new bu("New_5");this.LocalTemplatesLoaded=false;this.GlobalHoles=new bu("New_5");this.TextHoleRE="\\${([^}]+)}";this.RenderedFullDocTemplate=null;} });
function e8(hK){ let hL=null;let hM=0;const hN=hK.textContent;const hO=new RegExp(eO(), "g");while(hL=hO.exec(hN),hL!==null){ hK.parentNode.insertBefore(globalThis.document.createTextNode(fe(hN, bw(hM), bw(hO.lastIndex-bo(hL, 0).length-1))), hK);hM=hO.lastIndex;const hP=globalThis.document.createElement("span");hP.setAttribute("ws-replace", bo(hL, 1).toLowerCase());hK.parentNode.insertBefore(hP, hK);} hO.lastIndex=0;hK.textContent=fe(hN, bw(hM), null);}
function e9(hK){ console.warn("Instantiating non-loaded template", hK);}
function e_(hK, hL, hM){ const hN=hK.querySelector("[ws-replace]");return cM(hN, null)?(console.warn("Filling non-existent text hole", hM),null):(hN.parentNode.replaceChild(globalThis.document.createTextNode(hL), hN),bw(hN.getAttribute("ws-replace")));}
function e$(hK, hL){ const hM=(hN) => { eH(hK, "["+hN+"]", (hO) => { if(!hL.Contains(hO.getAttribute(hN)))hO.removeAttribute(hN);});};hM("ws-attr");hM("ws-onafterrender");hM("ws-var");eH(hK, "[ws-hole]", (hN) => { if(!hL.Contains(hN.getAttribute("ws-hole"))){ hN.removeAttribute("ws-hole");while(hN.hasChildNodes())hN.removeChild(hN.lastChild);} });eH(hK, "[ws-replace]", (hN) => { if(!hL.Contains(hN.getAttribute("ws-replace")))hN.parentNode.removeChild(hN);});eH(hK, "[ws-on]", (hN) => { hN.setAttribute("ws-on", dM(" ", ds((hO) => hL.Contains(bo(dI(hO, [":"], 1), 1)), dI(hN.getAttribute("ws-on"), [" "], 1))));});eH(hK, "[ws-attr-holes]", (hN) => { const hO=dI(hN.getAttribute("ws-attr-holes"), [" "], 1);for(let hS=0, hT=hO.length-1;hS<=hT;hS++){ const hP=bo(hO, hS);let hQ=new RegExp(eO(), "g");let hR=hN.getAttribute(hP).replace(hQ, (hU, hV) => hL.Contains(hV)?hU:"");hN.setAttribute(hP, hR);} });}
function fa(hK, hL){ fd(hL);const hM=hL.nodeName.toLowerCase();const hN=hK.querySelector("[ws-attr="+hM+"]");if(cM(hN, null))console.warn("Filling non-existent attr hole", hM);else { hN.removeAttribute("ws-attr");for(let hP=0, hQ=hL.attributes.length-1;hP<=hQ;hP++){ const hO=hL.attributes.item(hP);if(hO.name=="class"&&hN.hasAttribute("class"))hN.setAttribute("class", hN.getAttribute("class")+" "+hO.nodeValue);else hN.setAttribute(hO.name, hO.nodeValue);} } }
function fb(hK, hL){ const hM=(hN) => { eH(hK, "["+hN+"]", (hO) => { let hP;const hQ=(hP=null,[hL.TryGetValue(hO.getAttribute(hN).toLowerCase(), {get:() => hP, set:(hR) => { hP=hR;}}), hP]);if(hQ[0])hO.setAttribute(hN, hQ[1]);});};hM("ws-hole");hM("ws-replace");hM("ws-attr");hM("ws-onafterrender");hM("ws-var");eH(hK, "[ws-on]", (hN) => { hN.setAttribute("ws-on", dM(" ", dv((hO) => { let hP;const hQ=dI(hO, [":"], 1);const hR=(hP=null,[hL.TryGetValue(bo(hQ, 1), {get:() => hP, set:(hS) => { hP=hS;}}), hP]);return hR[0]?bo(hQ, 0)+":"+hR[1]:hO;}, dI(hN.getAttribute("ws-on"), [" "], 1))));});eH(hK, "[ws-attr-holes]", (hN) => { const hO=dI(hN.getAttribute("ws-attr-holes"), [" "], 1);for(let hP=0, hQ=hO.length-1;hP<=hQ;hP++)((() => { const hR=bo(hO, hP);return hN.setAttribute(hR, cb((hS, hT) => { const hU=u0033(hT);return hS.replace(new RegExp("\\${"+hU[0]+"}", "ig"), "${"+hU[1]+"}");}, hN.getAttribute(hR), hL));})());});}
function fc(hK, hL, hM){ while(true){ if(hK.hasChildNodes())hM=hL.insertBefore(hK.lastChild, hM);else return null;} }
function fd(hK){ const hL=hK.attributes;const hM=[];const hN=[];const hO=[];for(let hT=0, hU=hL.length-1;hT<=hU;hT++){ const hP=hL.item(hT);if(dG(hP.nodeName, "ws-on")&&hP.nodeName!="ws-onafterrender"&&hP.nodeName!="ws-on"){ hM.push(hP.nodeName);hN.push(fe(hP.nodeName, bw("ws-on".length), null)+":"+hP.nodeValue.toLowerCase());} else if(!dG(hP.nodeName, "ws-")&&(new RegExp(eO())).test(hP.nodeValue)){ let hQ=new RegExp(eO(), "g");let hR=hP.nodeValue.replace(hQ, (hV, hW) =>"${"+hW.toLowerCase()+"}");hP.nodeValue=hR;hO.push(hP.nodeName);} else void 0;} if(!(hN.length==0))hK.setAttribute("ws-on", dM(" ", hN));if(!(hO.length==0))hK.setAttribute("ws-attr-holes", dM(" ", hO));const hS=(hV) => { const hW=hK.getAttribute(hV);if(hW==null){ } else hK.setAttribute(hV, hW.toLowerCase());};hS("ws-hole");hS("ws-replace");hS("ws-attr");hS("ws-onafterrender");hS("ws-var");dp((hV) => { hK.removeAttribute(hV);}, hM);}
function fe(hK, hL, hM){ if(hL==null){ if(hM!=null&&hM.$==1){ const hN=hM.$0;return hN<0?"":hK.slice(0, hN+1);} else return"";} else if(hM==null)return hK.slice(hL.$0);else { const hO=hM.$0;return hO<0?"":hK.slice(hL.$0, hO+1);} }
function ff(hK){ const hL=globalThis.document.createElement("div");if(!fg().test(hK)){ hL.appendChild(globalThis.document.createTextNode(hK));return hL;} else { const hM=fk().exec(hK);const hN=cM(hM, null)?"":bo(hM, 1).toLowerCase();const hO=(fh())[hN];const hP=hO?hO:fi();hL.innerHTML=hP[1]+hK.replace(fj(), "<$1></$2>")+hP[2];function hQ(hR, hS){ while(true){ if(hS===0)return hR;else { const hT=hS;hR=hR.lastChild;hS=hT-1;} } } return hQ(hL, hP[0]);} }
function fg(){ return gL.rhtml;}
function fh(){ return gL.wrapMap;}
function fi(){ return gL.defaultWrap;}
function fj(){ return gL.rxhtmlTag;}
function fk(){ return gL.rtagName;}
function fl(hK, hL, hM){ const hN=hK.querySelectorAll(hL);for(let hO=0, hP=hN.length-1;hO<=hP;hO++)hM(hN[hO]);}
function fm(hK){ const hL=[];for(let hM=0, hN=hK.childNodes.length-1;hM<=hN;hM++)hL.push(hK.childNodes[hM]);return hL;}
function fn(hK, hL){ const hM=globalThis.document.querySelectorAll(hK);for(let hN=0, hO=hM.length-1;hN<=hO;hN++)hL(hM[hN]);}
function fo(hK, hL, hM){ let hN;if(hM.parentNode===hK){ const hO=hM.nextSibling;let hP=cM(hO, null)?null:hO;hN=hL===hP;} else hN=false;if(!hN)hK.insertBefore(hM, hL);}
function fp(hK, hL){ if(hL.parentNode===hK)hK.removeChild(hL);}
let fq=hB((hK) => { hF(c_);return class hL extends c_ { static { fq=hK(this);} docNode_1;updates_1;elt;rvUpdates;static TreeNode(hM, hN){ const hO=gl.Create(hN);const hP=dv((hS) => fL(hS[1]), hM.Attrs);let hQ=gh(Y(), u0031, hP);let hR=u0031(hQ, hO.v);return new hL(ec(hM), hR, bo(hM.Els, 0), hO);} constructor(hM, hN, hO, hP){ super(hM, hN);this.docNode_1=hM;this.updates_1=hN;this.elt=hO;this.rvUpdates=hP;} };});
function fr(){ return gv();}
function fs(hK){ const hL=null;return cp(() => cr(fu(() => { }, gw(hK)), () => { gx(hK);return cv(null);}));}
function ft(hK, hL){ return fv(gN(hK.$0, hL.$0));}
function fu(hK, hL){ const hM=hL.Duration;if(hM===0)return ct();else { const hN=(hO) => { function hP(hQ){ return(hR) => { const hS=hR-hQ;hL.Compute(hS);hK();return hS<=hM?void requestAnimationFrame((hT) => {(hP(hQ))(hT);}):hO();};} requestAnimationFrame((hQ) => {(hP(hQ))(hQ);});};return cC((hO, hP, hQ) => hN.apply(null, [hO, hP, hQ]));} }
function fv(hK){ return{$:0, $0:hK};}
function fw(hK){ return fv(gP(b2(gz, hK)));}
function fx(){ return fv(gQ());}
function fy(){ return gD.BatchUpdatesEnabled;}
function fz(hK){ const hL=[0];function hM(){ const hN=null;return cp(() => cr(hK, () => { const hO=hL[0];return cM(hO, 1)?(hL[0]=0,ct()):cM(hO, 2)?(hL[0]=1,hM()):ct();}));} return() => { const hN=hL[0];if(cM(hN, 0)){ hL[0]=1;cu(hM(), null);} else cM(hN, 1)?hL[0]=2:void 0;};}
let fA=hB((hK) => { hF(Error);return class hL extends Error { static { fA=hK(this);} ct;static New(hM){ return new this("New", hM);} static New_1(hM, hN, hO){ return new this("New_1", hM, hN, hO);} constructor(hM, hN, hO, hP){ let hQ;if(hM=="New"){ hQ=hN;hM="New_1";hN="The operation was canceled.";hO=null;hP=hQ;} if(hM=="New_1"){ const hR=hN;const hS=hO;const hT=hP;super(hR);this.inner=hS;this.ct=hT;} } };});
function fB(hK, hL, hM, hN){ const hO={DynElem:hK, DynFlags:hL, DynNodes:hM};hE(hO, "OnAfterRender", hN);return hO;}
function fC(hK){ const hL=dh(ce(hK));dt(hL);return fE(hL, 0, hL.length-1);}
function fD(hK, hL){ function hM(hN, hO){ let hP;while(true){ if(hN==null)return hO.$==1?bw([hO.$0[0], [hO.$0[1], hO.$1]]):null;else if(hK){ hP=hN;hN=hP.Right;hO=h.Cons([hP.Node, hP.Left], hO);} else { hP=hN;hN=hP.Left;hO=h.Cons([hP.Node, hP.Right], hO);} } } return cg((hN) => hM(hN[0], hN[1]), [hL, h.Empty]);}
function fE(hK, hL, hM){ if(hM-hL+1<=0)return null;else { const hN=(hL+hM)/2>>0;return fF(bo(hK, hN), fE(hK, hL, hN-1), fE(hK, hN+1, hM));} }
function fF(hK, hL, hM){ const hN=hL==null?0:hL.Height;const hO=hM==null?0:hM.Height;let hP=cU(hN, hO)===1?hN:hO;let hQ=1+hP;return eS(hK, hL, hM, hQ, 1+(hL==null?0:hL.Count)+(hM==null?0:hM.Count));}
function fG(hK, hL){ return fH((hM, hN) => hN, hK, hL);}
function fH(hK, hL, hM){ const hN=fI(hL, hM);const hO=hN[0];return hO==null?fJ(hN[1], fF(hL, null, null)):fJ(hN[1], fF(hK(hO.Node, hL), hO.Left, hO.Right));}
function fI(hK, hL){ let hM=[];let hN=hL;let hO=true;while(hO)if(hN==null)hO=false;else { const hP=cU(hK, hN.Node);if(hP===0)hO=false;else hP===1?(hM.unshift([true, hN.Node, hN.Left]),hN=hN.Right):(hM.unshift([false, hN.Node, hN.Right]),hN=hN.Left);} return[hN, hM];}
function fJ(hK, hL){ const hM=(hV) => hV==null?0:hV.Height;let hN=hL;for(let hV=0, hW=bp(hK)-1;hV<=hW;hV++){ const hO=bo(hK, hV);if(hO[0]){ const hP=hO[1];const hQ=hO[2];if(hM(hN)>hM(hQ)+1){ if(hM(hN.Left)===hM(hN.Right)+1){ const hR=hN.Left;hN=fF(hR.Node, fF(hP, hQ, hR.Left), fF(hN.Node, hR.Right, hN.Right));} else hN=fF(hN.Node, fF(hP, hQ, hN.Left), hN.Right);} else hN=fF(hP, hQ, hN);} else { const hS=hO[1];const hT=hO[2];if(hM(hN)>hM(hT)+1){ if(hM(hN.Right)===hM(hN.Left)+1){ const hU=hN.Right;hN=fF(hU.Node, fF(hN.Node, hN.Left, hU.Left), fF(hS, hU.Right, hT));} else hN=fF(hN.Node, hN.Left, fF(hS, hN.Right, hT));} else hN=fF(hS, hN, hT);} } return hN;}
function fK(hK, hL){ const hM=[];const hN=[];function hO(hR){ while(true){ if(!(hR===null)){ if(hR!=null&&hR.$==1)return hM.push(hR.$0);else if(hR!=null&&hR.$==2){ const hS=hR.$1;const hT=hR.$0;hO(hT);hR=hS;} else return hR!=null&&hR.$==3?hR.$0(hK):hR!=null&&hR.$==4?hN.push(hR.$0):null;} else return null;} } hO(hL);const hP=hM.slice(0);let hQ=fB(hK, fN(hL), hP, hN.length===0?null:bw((hR) => { cf((hS) => { hS(hR);}, hN);}));return hQ;}
function fL(hK){ return gk((hL) => hL.NChanged, Y(), u0031, hK.DynNodes);}
function fM(hK){ return fB(hK, 0, [], null);}
function fN(hK){ return hK!==null&&hK.hasOwnProperty("flags")?hK.flags:0;}
function fO(hK){ return gc.A3(hK);}
function fP(hK, hL){ return gc.A1(new gS(hK, hL));}
function fQ(){ return gT.EmptyAttr;}
function fR(hK){ const hL=2;return(hK.DynFlags&hL)===hL;}
function fS(hK){ return fY(hK, (hL, hM) => hL.NGetExitAnim(hM));}
function fT(hK){ const hL=1;return(hK.DynFlags&hL)===hL;}
function fU(hK){ return fY(hK, (hL, hM) => hL.NGetEnterAnim(hM));}
function fV(hK){ const hL=4;return(hK.DynFlags&hL)===hL;}
function fW(hK){ return fY(hK, (hL, hM) => hL.NGetChangeAnim(hM));}
function fX(hK, hL){ if(hK===null)return hL;else if(hL===null)return hK;else { const hM=gc.A2(hK, hL);f0(hM, fN(hK)|fN(hL));return hM;} }
function fY(hK, hL){ return fw(dv((hM) => hL(hM, hK.DynElem), hK.DynNodes));}
function fZ(hK, hL){ dp((hM) => { hM.NSync(hK);}, hL.DynNodes);}
function f0(hK, hL){ hK.flags=hL;}
let f1=hB((hK) => { hF(bt);return class hL extends bt { static { f1=hK(this);} name;fillWith;get Value(){ return this.fillWith;} get Name(){ return this.name;} };});
let f2=hB((hK) => { hF(bt);return class hL extends bt { static { f2=hK(this);} name;fillWith;get Value(){ return this.fillWith;} get Name(){ return this.name;} };});
function f3(hK, hL){ return fO((hM) => { hM.addEventListener(hK, (hN) =>(hL(hM))(hN), false);});}
function f4(hK){ return gc.A4(hK);}
function f5(hK, hL){ return fP(hL, (hM) =>(hN) => hM.setAttribute(hK, hN));}
function f6(hK){ return ga(hf(), hK);}
function f7(hK){ return ga(hg(), hK);}
function f8(hK){ return ga(hh(), hK);}
function f9(hK){ return ga(hi(), hK);}
function f_(hK){ return ga(hj(), hK);}
function f$(hK){ return ga(hk(), hK);}
function ga(hK, hL){ const hM=hK(hL);return gc.Append(fO(hM[0]), gb(hM[1], hM[2]));}
function gb(hK, hL){ return fP(hL, hK);}
let gc=hB((hK) => class hL { static { gc=hK(this);} static Handler(hM, hN){ return gc.HandlerImpl(hM, hN);} static Concat(hM){ const hN=gj(hM);return gh(fQ(), gc.Append, hN);} static Create(hM, hN){ return fO((hO) => { hO.setAttribute(hM, hN);});} static HandlerImpl(hM, hN){ return fO((hO) => { hO.addEventListener(hM, (hP) =>(hN(hO))(hP), false);});} static Append(hM, hN){ return fX(hM, hN);} static A4(hM){ return hC(hL, {$:4, $0:hM});} static A3(hM){ return hC(hL, {$:3, $0:hM});} static A1(hM){ return hC(hL, {$:1, $0:hM});} static A2(hM, hN){ return hC(hL, {$:2, $0:hM, $1:hN});} });
let gd=hB((hK) => { hF(bt);return class hL extends bt { static { gd=hK(this);} name;fillWith;get Value(){ return this.fillWith;} get Name(){ return this.name;} };});
let ge=hB((hK) => { hF(bt);return class hL extends bt { static { ge=hK(this);} name;fillWith;get Value(){ return this.fillWith;} get Name(){ return this.name;} };});
function gf(hK){ return{$:0, $0:hK};}
function gg(hK){ return{$:1, $0:hK};}
function gh(hK, hL, hM){ const hN=bp(hM);function hO(hP){ return(hQ) => { let hR;switch(hQ<=0?0:hQ===1?hP>=0&&hP<hN?1:(hR=hQ,2):(hR=hQ,2)){ case 0:return hK;case 1:return bo(hM, hP);case 2:const hS=hQ/2>>0;return hL((hO(hP))(hS), (hO(hP+hS))(hQ-hS));} };} return(hO(0))(hN);}
function gi(hK, hL){ for(let hM=0, hN=hL.length-1;hM<=hN;hM++)hL[hM]=hK(hL[hM]);return hL;}
function gj(hK){ if(hK instanceof Array)return hK;else if(hK instanceof h)return di(hK);else if(hK===null)return[];else { const hL=[];const hM=cI(hK);try { while(hM.MoveNext())hL.push(hM.Current);return hL;} finally { if(typeof hM=="object"&&a(hM))hM.Dispose();} } }
function gk(hK, hL, hM, hN){ const hO=bp(hN);function hP(hQ){ return(hR) => { let hS;switch(hR<=0?0:hR===1?hQ>=0&&hQ<hO?1:(hS=hR,2):(hS=hR,2)){ case 0:return hL;case 1:return hK(bo(hN, hQ));case 2:const hT=hR/2>>0;return hM((hP(hQ))(hT), (hP(hQ+hT))(hR-hT));} };} return(hP(0))(hO);}
let gl=hB((hK) => class hL { static { gl=hK(this);} c;s;v;static Create(hM){ let hN;hN=null;hN=gl.New(hM, null, () => { let hO;hO=hN.s;return hO===null?(hO=bO(hN.c()),hN.s=hO,bB(hO, () => { hN.s=null;}),hO):hO;});return hN;} static New(hM, hN, hO){ return hC(gl, {c:hM, s:hN, v:hO});} });
let gm=hB((hK) => class hL extends f { static { gm=hK(this);} d;GetEnumerator(){ return cI(b2((hM) => hM.V, this.d));} constructor(hM){ super();this.d=hM;} });
function gn(hK, hL){ return{PreviousNodes:hK, Top:hL};}
function go(){ return gq(new en("New_3"));}
function gp(hK){ const hL=[];function hM(hP, hQ){ while(true)switch(hP){ case 0:if(hQ!=null&&hQ.$==0){ const hR=hQ.$1;const hS=hQ.$0;hM(0, hS);hQ=hR;} else if(hQ!=null&&hQ.$==1){ const hT=hQ.$0;hQ=hT;hP=1;} else if(hQ!=null&&hQ.$==2){ const hU=hQ.$0;hQ=hU.Current;} else if(hQ!=null&&hQ.$==6){ const hV=hQ.$0.Holes;return(((hW) =>(hX) => { dp(hW, hX);})(hO))(hV);} else return null;break;case 1:hL.push(hQ);hQ=hQ.Children;hP=0;break;} } function hN(hP){ return hM(0, hP);} function hO(hP){ return hM(1, hP);} hN(hK);return gq(new en("New_2", hL));}
function gq(hK){ return{$:0, $0:hK};}
function gr(hK, hL){ return gq(gV(hK, hL.$0));}
function gs(hK, hL){ return gq(gW(hK.$0, hL.$0));}
function gt(hK){ return gX(hK.$0);}
function gu(hK, hL){ return gq(gY(hK.$0, hL.$0));}
function gv(){ return gM.UseAnimations;}
function gw(hK){ return gy(dn((hL) => hL.$==1?bw(hL.$0):null, gO(hK.$0)));}
function gx(hK){ dp((hL) => { if(hL.$==0)hL.$0();}, gO(hK.$0));}
function gy(hK){ const hL=gj(hK);const hM=bp(hL);if(hM===0)return gA();else if(hM===1)return bo(hL, 0);else { const hN=ch(b2((hP) => hP.Duration, hL));const hO=dv((hP) => gC(hN, hP), hL);return gB(hN, (hP) => { dp((hQ) => { hQ.Compute(hP);}, hO);});} }
function gz(hK){ return hK.$0;}
function gA(hK){ return gB(0, () => hK);}
function gB(hK, hL){ return{Compute:hL, Duration:hK};}
function gC(hK, hL){ const hM=hL.Compute;const hN=hL.Duration;const hO=hv(() => hL.Compute(hL.Duration));return{Compute:(hP) => hP>=hN?hO.f():hM(hP), Duration:hK};}
let gD=hB((hK) => class hL { static { gD=hK(this);} static BatchUpdatesEnabled;static { this.BatchUpdatesEnabled=true;} });
function gE(){ return u0032("The input sequence has an insufficient number of elements.");}
function gF(hK, hL){ for(let hM=0, hN=hL.length-1;hM<=hN;hM++)hL[hM]=hK(hM, hL[hM]);return hL;}
function gG(hK, hL){ for(let hM=0, hN=hL.length-1;hM<=hN;hM++)hL[hM]=hK(hL[hM]);}
function gH(hK, hL){ let hM=true;let hN=0;while(hM&&hN<bp(hL))if(cM(hL[hN], hK))hM=false;else hN=hN+1;return!hM;}
function gI(){ return u0032("The input must be non-negative.");}
let gJ=hB((hK) => class hL extends f { static { gJ=hK(this);} d;GetEnumerator(){ return cI(b2((hM) => hM.K, this.d));} constructor(hM){ super();this.d=hM;} });
function gK(hK){ let hL=[];let hM;for(var hN in hK)hL.push.apply(hL, hK[hN]);return hL;}
let gL=hB((hK) => class hL { static { gL=hK(this);} static defaultWrap;static wrapMap;static rhtml;static rtagName;static rxhtmlTag;static { this.rxhtmlTag=new RegExp("<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>", "gi");this.rtagName=new RegExp("<([\\w:]+)");this.rhtml=new RegExp("<|&#?\\w+;");const hM=[1, "<table>", "</table>"];let hN=Object.fromEntries([["option", [1, "<select multiple='multiple'>", "</select>"]], ["legend", [1, "<fieldset>", "</fieldset>"]], ["area", [1, "<map>", "</map>"]], ["param", [1, "<object>", "</object>"]], ["thead", hM], ["tbody", hM], ["tfoot", hM], ["tr", [2, "<table><tbody>", "</tbody></table>"]], ["col", [2, "<table><colgroup>", "</colgoup></table>"]], ["td", [3, "<table><tbody><tr>", "</tr></tbody></table>"]]]);this.wrapMap=hN;this.defaultWrap=[0, "", ""];} });
let gM=hB((hK) => class hL { static { gM=hK(this);} static UseAnimations;static CubicInOut;static { this.CubicInOut=gU.Custom((hM) => { const hN=hM*hM;return 3*hN-2*(hN*hM);});this.UseAnimations=true;} });
function gN(hK, hL){ return hK.$==0?hL:hL.$==0?hK:{$:2, $0:hK, $1:hL};}
function gO(hK){ const hL=[];function hM(hN){ while(true){ if(hN.$==1)return hL.push(hN.$0);else if(hN.$==2){ const hO=hN.$1;const hP=hN.$0;hM(hP);hN=hO;} else return hN.$==3?dp((hQ) => { hL.push(hQ);}, hN.$0):null;} } hM(hK);return hL.slice(0);}
function gP(hK){ const hL=gj(hK);return gh(gQ(), gN, hL);}
function gQ(){ return hy.Empty;}
let gR=hB((hK) => { hF(Error);return class hL extends Error { static { gR=hK(this);} static New(){ return new this("New");} static New_1(hM){ return new this("New_1", hM);} constructor(hM, hN){ if(hM=="New"){ hM="New_1";hN="The given key was not present in the dictionary.";} if(hM=="New_1"){ const hO=hN;super(hO);} } };});
let gS=hB((hK) => class hL extends f { static { gS=hK(this);} push;value;dirty;updates;get NChanged(){ return this.updates;} NGetExitAnim(hM){ return fx();} NGetEnterAnim(hM){ return fx();} NGetChangeAnim(hM){ return fx();} NSync(hM){ if(this.dirty){(this.push(hM))(this.value);this.dirty=false;} } constructor(hM, hN){ super();this.push=hN;this.value=void 0;this.dirty=false;this.updates=R((hO) => { this.value=hO;this.dirty=true;}, hM);} });
let gT=hB((hK) => class hL { static { gT=hK(this);} static FloatApplyChecked;static FloatGetChecked;static FloatSetChecked;static FloatApplyUnchecked;static FloatGetUnchecked;static FloatSetUnchecked;static IntApplyChecked;static IntGetChecked;static IntSetChecked;static IntApplyUnchecked;static IntGetUnchecked;static IntSetUnchecked;static FileApplyUnchecked;static FileGetUnchecked;static FileSetUnchecked;static DateTimeApplyUnchecked;static DateTimeGetUnchecked;static DateTimeSetUnchecked;static StringListApply;static StringListGet;static StringListSet;static StringApply;static StringGet;static StringSet;static BoolCheckedApply;static EmptyAttr;static { this.EmptyAttr=null;this.BoolCheckedApply=(h2) =>[(h3) => { h3.addEventListener("change", () => h2.Get()!=h3.checked?h2.Set(h3.checked):null);}, (h3) =>(h4) => h4!=null&&h4.$==1?void(h3.checked=h4.$0):null, R(bw, h2.View)];this.StringSet=(h2) =>(h3) => { h2.value=h3;};this.StringGet=(h2) => bw(h2.value);const hM=g1();const hN=g0();this.StringApply=(h2) => gZ(hM, hN, h2);this.StringListSet=(h2) =>(h3) => { const h4=h2.options;for(let h5=0, h6=h4.length-1;h5<=h6;h5++)((() => { const h7=h4.item(h5);h7.selected=gH(h7.value, h3);})());};this.StringListGet=(h2) => { const h3=h2.selectedOptions;return bw(dh(cd(() => bZ((h4) =>[h3.item(h4).value], u0034(0, h3.length-1)))));};const hO=g3();const hP=g2();this.StringListApply=(h2) => gZ(hO, hP, h2);this.DateTimeSetUnchecked=(h2) =>(h3) => { h2.value=(new Date(h3)).toLocaleString();};this.DateTimeGetUnchecked=(h2) => { let h3;let h4;const h5=h2.value;if(hl(h5))return bw(-8640000000000000);else { h3=0;const h6=ht(h5);let h7=h6!=null&&h6.$==1&&(h3=h6.$0,true);h4=[h7, h3];return h4[0]?bw(h4[1]):null;} };const hQ=g5();const hR=g4();this.DateTimeApplyUnchecked=(h2) => gZ(hQ, hR, h2);this.FileSetUnchecked=() =>() => null;this.FileGetUnchecked=(h2) => { const h3=h2.files;return bw(dh(cd(() => b2((h4) => h3.item(h4), u0034(0, h3.length-1)))));};const hS=g8();const hT=g7();this.FileApplyUnchecked=(h2) => g6(hS, hT, h2);this.IntSetUnchecked=(h2) =>(h3) => { h2.value=String(h3);};this.IntGetUnchecked=(h2) => { const h3=h2.value;if(hl(h3))return bw(0);else { const h4=+h3;return h4!==h4>>0?null:bw(h4);} };const hU=g_();const hV=g9();this.IntApplyUnchecked=(h2) => gZ(hU, hV, h2);this.IntSetChecked=(h2) =>(h3) => { const h4=h3.Input;return h2.value!=h4?void(h2.value=h4):null;};this.IntGetChecked=(h2) => { let h3;let h4;const h5=h2.value;if(hl(h5))h3=(h2.checkValidity?h2.checkValidity():true)?hm.Blank(h5):hm.Invalid(h5);else { const h6=(h4=0,[c$(h5, {get:() => h4, set:(h7) => { h4=h7;}}), h4]);h3=h6[0]?hm.Valid(h6[1], h5):hm.Invalid(h5);} return bw(h3);};const hW=ha();const hX=g$();this.IntApplyChecked=(h2) => gZ(hW, hX, h2);this.FloatSetUnchecked=(h2) =>(h3) => { h2.value=String(h3);};this.FloatGetUnchecked=(h2) => { const h3=h2.value;if(hl(h3))return bw(0);else { const h4=+h3;return isNaN(h4)?null:bw(h4);} };const hY=hc();const hZ=hb();this.FloatApplyUnchecked=(h2) => gZ(hY, hZ, h2);this.FloatSetChecked=(h2) =>(h3) => { const h4=h3.Input;return h2.value!=h4?void(h2.value=h4):null;};this.FloatGetChecked=(h2) => { let h3;const h4=h2.value;if(hl(h4))h3=(h2.checkValidity?h2.checkValidity():true)?hm.Blank(h4):hm.Invalid(h4);else { const h5=+h4;h3=isNaN(h5)?hm.Invalid(h4):hm.Valid(h5, h4);} return bw(h3);};const h0=he();const h1=hd();this.FloatApplyChecked=(h2) => gZ(h0, h1, h2);} });
let gU=hB((hK) => class hL extends f { static { gU=hK(this);} transformTime;static Custom(hM){ return new hL(hM);} constructor(hM){ super();this.transformTime=hM;} });
function gV(hK, hL){ return new en("New_2", ds(hK, gX(hL)));}
function gW(hK, hL){ const hM=new en("New_2", gX(hL));hM.ExceptWith(gX(hK));return hM;}
function gX(hK){ const hL=dy(hK.Count, void 0);hK.CopyTo(hL, 0);return hL;}
function gY(hK, hL){ const hM=new en("New_2", gX(hK));hM.IntersectWith(gX(hL));return hM;}
function gZ(hK, hL, hM){ let hN;hN=null;return[(hO) => { const hP=() => { hM.UpdateMaybe((hQ) => { let hR;hN=hK(hO);return hN!=null&&hN.$==1&&(!cM(hN.$0, hQ)&&(hR=[hN, hN.$0],true))?hR[0]:null;});};hO.addEventListener("change", hP);hO.addEventListener("input", hP);hO.addEventListener("keypress", hP);}, (hO) => { const hP=hL(hO);return(hQ) => hQ==null?null:hP(hQ.$0);}, R((hO) => { let hP;return hN!=null&&hN.$==1&&(cM(hN.$0, hO)&&(hP=hN.$0,true))?null:bw(hO);}, hM.View)];}
function g0(){ return gT.StringSet;}
function g1(){ return gT.StringGet;}
function g2(){ return gT.StringListSet;}
function g3(){ return gT.StringListGet;}
function g4(){ return gT.DateTimeSetUnchecked;}
function g5(){ return gT.DateTimeGetUnchecked;}
function g6(hK, hL, hM){ let hN;hN=null;return[(hO) => { hO.addEventListener("change", () => { hM.UpdateMaybe((hP) => { let hQ;hN=hK(hO);return hN!=null&&hN.$==1&&(hN.$0!==hP&&(hQ=[hN, hN.$0],true))?hQ[0]:null;});});}, (hO) => { const hP=hL(hO);return(hQ) => hQ==null?null:hP(hQ.$0);}, R((hO) => { let hP;return hN!=null&&hN.$==1&&(cM(hN.$0, hO)&&(hP=hN.$0,true))?null:bw(hO);}, hM.View)];}
function g7(){ return gT.FileSetUnchecked;}
function g8(){ return gT.FileGetUnchecked;}
function g9(){ return gT.IntSetUnchecked;}
function g_(){ return gT.IntGetUnchecked;}
function g$(){ return gT.IntSetChecked;}
function ha(){ return gT.IntGetChecked;}
function hb(){ return gT.FloatSetUnchecked;}
function hc(){ return gT.FloatGetUnchecked;}
function hd(){ return gT.FloatSetChecked;}
function he(){ return gT.FloatGetChecked;}
function hf(){ return gT.FloatApplyUnchecked;}
function hg(){ return gT.StringApply;}
function hh(){ return gT.BoolCheckedApply;}
function hi(){ return gT.DateTimeApplyUnchecked;}
function hj(){ return gT.FileApplyUnchecked;}
function hk(){ return gT.StringListApply;}
function hl(hK){ return dP(hs, hK);}
let hm=hB((hK) => class hL { static { hm=hK(this);} get Input(){ return this.$==1?this.$0:this.$==2?this.$0:this.$1;} static Blank(hM){ return hC(hL, {$:2, $0:hM});} static Invalid(hM){ return hC(hL, {$:1, $0:hM});} static Valid(hM, hN){ return hC(hL, {$:0, $0:hM, $1:hN});} });
function hn(hK, hL){ let hM;if(hL!=null&&hL.$==1){ const hN=[];hM=hL.$0[0].nextSibling;while(hM!==hL.$0[1]){ hN.push(hM);hM=hM.nextSibling;} return hr(hN);} else { let hO=hK.childNodes.length;const hP=hK.childNodes;let hQ=dl(hO, (hR) => hP[hR]);return hr(hQ);} }
function ho(hK, hL){ const hM=hK.$0;return hr(ds((hN) => dk((hO) =>!(hN===hO), hM), hL.$0));}
function hp(hK, hL){ dp(hK, hL.$0);}
function hq(hK){ const hL=[];function hM(hN){ while(true){ if(hN!=null&&hN.$==2){ const hO=hN.$0;hN=hO.Current;} else if(hN!=null&&hN.$==1)return hL.push(hN.$0.El);else if(hN==null)return null;else if(hN!=null&&hN.$==5)return hL.push(hN.$0);else if(hN!=null&&hN.$==4)return hL.push(hN.$0.Text);else if(hN!=null&&hN.$==6){ const hP=hN.$0.Els;return(((hS) =>(hT) => { dp(hS, hT);})((hS) => { if(hS==null||hS.constructor===Object)hM(hS);else hL.push(hS);}))(hP);} else { const hQ=hN.$1;const hR=hN.$0;hM(hR);hN=hQ;} } } hM(hK.Children);return hr(gj(hL));}
function hr(hK){ return{$:0, $0:hK};}
function hs(hK){ return hK.match(new RegExp("\\s"))!==null;}
function ht(hK){ const hL=Date.parse(hK);return isNaN(hL)?null:bw(hL);}
function hu(hK, hL, hM, hN){ const hO=+hK;const hP=hO===hO-hO%1&&hO>=hL&&hO<=hM;if(hP)hN.set(hO);return hP;}
function hv(hK){ return hz(false, hK, hw);}
function hw(){ const hK=this.v();this.c=true;this.v=hK;this.f=hx;return hK;}
function hx(){ return this.v;}
let hy=hB((hK) => class hL { static { hy=hK(this);} static Empty;static { this.Empty={$:0};} });
function hz(hK, hL, hM){ return{c:hK, v:hL, f:hM};}
hJ(() => { b();});
hA();

